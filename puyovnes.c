//custom config file, explained there http://8bitworkshop.com/blog/docs/ide.md.html#8bitworkshopideusermanual/managingfiles/cc65customconfigfiles
#define CFGFILE puyovnes.cfg
//#resource "puyovnes.cfg"

#include <stdlib.h>
#include <string.h>

#include <stdio.h>

// include NESLIB header
#include "neslib.h"

// include CC65 NES Header (PPU)
#include <nes.h>

// link the pattern table into CHR ROM
//#link "chr_generic.s"

///// METASPRITES

// define a 2x2 metasprite
#define DEF_METASPRITE_2x2(name,code,pal)\
const unsigned char name[]={\
        0,      0,      (code)+0,   pal, \
        0,      8,      (code)+1,   pal, \
        8,      0,      (code)+2,   pal, \
        8,      8,      (code)+3,   pal, \
        128};

// define a 2x2 metasprite, flipped horizontally
#define DEF_METASPRITE_2x2_FLIP(name,code,pal)\
const unsigned char name[]={\
        8,      0,      (code)+0,   (pal)|OAM_FLIP_H, \
        8,      8,      (code)+1,   (pal)|OAM_FLIP_H, \
        0,      0,      (code)+2,   (pal)|OAM_FLIP_H, \
        0,      8,      (code)+3,   (pal)|OAM_FLIP_H, \
        128};

// BCD arithmetic support
#include "bcd.h"
//#link "bcd.c"

#include "apu.h"
//#link "apu.c"

// VRAM update buffer
#include "vrambuf.h"
//#link "vrambuf.c"

//Sample bayoen in asm
//#link "bayoen.s"


// number of rows in scrolling playfield (without status bar)
#define PLAYROWS 30
#define PLAYCOLUMNS 32
// RNG, from BluBlue On bayoen discord
/*dans le vrai Tsu, le jeu prend 256 puyos répartis équitablement avec les 4 couleurs de la partie, donc 64 de chaque
il les mélange en les échangeant de place
la liste qui en résulte est la suite de paires qu'on aura : les deux premiers forment la première paire, etc*/
// He has also completely deconstruct the RNG of puyo there: https://puyonexus.com/wiki/Puyo_Puyo_Tsu/Random_Number_Generator
// For my own sanity I will build my own RNG based on the principal of 4*64 colors being used 
#define NBCOLORPOOL 64
//256 puyos = 128 pairs...
//an attribute table entry is 2 bits, so 1 puyo = 2bits
//a pair of puyo = 4 bits
//with 8 bits we have 2 pairs
//So we need an array length of 64 bytes/char to stock everything, amazing !
#define PUYOLISTLENGTH 64

/// GLOBAL VARIABLES
//note on CellType: PUYO_RED is first and not EMPTY for 0, because it's matching the attribute table
//(I think I will regret that decision later...)
typedef enum CellType {PUYO_RED, PUYO_BLUE, PUYO_GREEN, PUYO_YELLOW, OJAMA, EMPTY, PUYO_POP};
typedef enum Step {PLAY, CHECK, CHECK_ALL, DESTROY, FALL, POINT, SHOW_NEXT, FALL_OJAMA, FLUSH};
word x_scroll;		// X scroll amount in pixels
byte seg_height;	// segment height in metatiles
byte seg_width;		// segment width in metatiles
byte seg_char;		// character to draw
byte seg_palette;	// attribute table value
byte step_p1, step_p2;
byte step_p1_counter, step_p2_counter;// indicates where we are in the process.
// attribute table in PRG ROM
byte attribute_table[64];/* = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // rows 0-3
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // rows 4-7
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // rows 8-11
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // rows 12-15
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // rows 16-19
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // rows 20-23
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // rows 24-27
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // rows 28-29
};*/
//both play tables can be stored in a 6*13 array of byte
//4 LSB are for board one, value car by of type CellType (1 bit unused), so must use &0xf to get correct value 
//4 MSB are for 2nd board, so must use >>4 to get correct value, or even better (value&240)>>4, probably overkill
//and still 1 bit unused.
//[0][0] is top left, [5][12] is bottom right, keeping same axis than display for simplification
byte boards[6][13];
//for sake of simplicity keeping the same table type for tmp
//but we may look for something less huge in size later.
byte tmp_boards[6][13];

// buffers that hold vertical slices of nametable data
char ntbuf1[PLAYROWS];	// left side
char ntbuf2[PLAYROWS];	// right side

// a vertical slice of attribute table entries
char attrbuf[PLAYROWS/4];

// nos sprites de puyo
DEF_METASPRITE_2x2(puyo_red, 0xd8, 0);//red
DEF_METASPRITE_2x2(puyo_blue, 0xd8, 1);//blue
DEF_METASPRITE_2x2(puyo_green, 0xd8, 2);//green
DEF_METASPRITE_2x2(puyo_yellow, 0xd8, 3);//yellow
DEF_METASPRITE_2x2(ojama, 0xdc, 0);
DEF_METASPRITE_2x2(puyo_pop, 0xe0, 0);

//will listed all our puyo to come, generated by RNG
char puyo_list[PUYOLISTLENGTH];
char p1_puyo_list_index;
char p2_puyo_list_index;

// number of actors (4 h/w sprites each)
// 12 : 2 active on each players screen
// and 4 for preview on each side
#define NUM_ACTORS 4

// actor x/y positions
byte actor_x[NUM_ACTORS];
byte actor_y[NUM_ACTORS];
// actor x/y deltas per frame (signed)
sbyte actor_dx[NUM_ACTORS];
sbyte actor_dy[NUM_ACTORS];

//Variables for damages 
//cf https://www.bayoen.fr/wiki/Tableau_des_dommages for how to compute damages.
byte nb_puyos_destroyed[2]; //how many puyos are destroyed on that hit
byte nb_hit[2];// hit combo counter
byte mask_color_destroyed; // LSB p1, MSB p2, bit mask at 1 for each color present in the hit. bit 0 red, bit 1 blue, bit 2 green, 3 yellow 
byte nb_group[2];//if the group is over 4 puyos add the part over in this variable.
unsigned long int score[2];
unsigned long int ojamas[4];// 2 pockets of ojama per player, but what is displayed is always the sum of both. Warikomi rule.
byte step_ojama_fall[2];

//INPUT BUFFER DELAY
#define INPUT_DIRECTION_DELAY 4
#define INPUT_BUTTON_DELAY 4
//previously declared in main()
char oam_id;	// sprite ID
char pad;	// controller flags
char previous_pad[2];
char input_delay_PAD_LEFT[2]; //to avoid multiple input on one press
char input_delay_PAD_RIGHT[2]; //to avoid multiple input on one press
char input_delay_PAD_A[2]; //to avoid multiple input on one press
char input_delay_PAD_B[2]; //to avoid multiple input on one press
char column_height[12]; // heigth of the stack, 0 to 5 p1, 6 to 11 P2, may not be the best strategy
//constant for puyo physics
#define GRACE_PERIOD 32
#define MAX_FALLING_BACK_UP 8
byte timer_grace_period[2];
byte counter_falling_back_up[2];


//
// MUSIC ROUTINES
//

// Namespace(bias=1.0, freq=111860.8, length=64, maxbits=13.0, upper=41)
// 439.0 0.943191918851 41
const int note_table_41[64] = {
4318, 4076, 3847, 3631, 3427, 3235, 3053, 2882, 2720, 2567, 2423, 2287, 2159, 2037, 1923, 1815, 1713, 1617, 1526, 1440, 1360, 1283, 1211, 1143, 1079, 1018, 961, 907, 856, 808, 763, 720, 679, 641, 605, 571, 539, 509, 480, 453, 428, 403, 381, 359, 339, 320, 302, 285, 269, 254, 240, 226, 213, 201, 190, 179, 169, 160, 151, 142, 134, 126, 119, 113, };

// Namespace(bias=1.0, freq=111860.8, length=64, maxbits=13, upper=49)
// 440.5 1.79281159771 49
const int note_table_49[64] = {
4304, 4062, 3834, 3619, 3416, 3224, 3043, 2872, 2711, 2559, 2415, 2279, 2151, 2031, 1917, 1809, 1707, 1611, 1521, 1436, 1355, 1279, 1207, 1139, 1075, 1015, 958, 904, 853, 805, 760, 717, 677, 639, 603, 569, 537, 507, 478, 451, 426, 402, 379, 358, 338, 319, 301, 284, 268, 253, 239, 225, 213, 201, 189, 179, 168, 159, 150, 142, 134, 126, 119, 112, };

// Namespace(bias=1.0, freq=111860.8, length=64, maxbits=12, upper=63)
// 443.6 14.2328382554 63
const int note_table_63[64] = {
2137, 4034, 3807, 3593, 3392, 3201, 3022, 2852, 2692, 2541, 2398, 2263, 2136, 2016, 1903, 1796, 1695, 1600, 1510, 1425, 1345, 1270, 1199, 1131, 1068, 1008, 951, 898, 847, 800, 755, 712, 672, 634, 599, 565, 533, 503, 475, 448, 423, 399, 377, 356, 336, 317, 299, 282, 266, 251, 237, 224, 211, 199, 188, 177, 167, 158, 149, 141, 133, 125, 118, 111, };

// Namespace(bias=-1.0, freq=55930.4, length=64, maxbits=12, upper=53)
// 443.7 8.47550713772 53
const int note_table_tri[64] = {
2138, 2018, 1905, 1798, 1697, 1602, 1512, 1427, 1347, 1272, 1200, 1133, 1069, 1009, 953, 899, 849, 801, 756, 714, 674, 636, 601, 567, 535, 505, 477, 450, 425, 401, 379, 358, 338, 319, 301, 284, 268, 253, 239, 226, 213, 201, 190, 179, 169, 160, 151, 142, 135, 127, 120, 113, 107, 101, 95, 90, 85, 80, 76, 72, 68, 64, 60, 57, };

#define NOTE_TABLE note_table_49
#define BASS_NOTE /*36*/ 12

byte music_index = 0;
byte cur_duration = 0;

const byte music1[]; // music data -- see end of file
const byte* music_ptr = music1;
#define SAMPLE_TEST 0xF800
//const byte bayoen[];
//extern const void * bayoen_sample_data[];

//end of music bloc

//le const machin const permet de placer l'info en rom et donc de gagner de la place en théorie
const unsigned char* const puyoSeq[6] = {
  puyo_red, puyo_blue, puyo_green, puyo_yellow, ojama, puyo_pop
};
//1:    0xfc   ojama
//6:    0xf8   big ojama
//30:   0xe4   rock
//180:  0xe8   tilted rock
//360:  0xec   star
//720:  0xf0   crown
//1440: 0xf4   comet
const unsigned int const damageList[7] = 
{ 
  1440,720,360,180,30,6,1
};

const byte const damageTile[7] = 
{ 
  0xf4,0xf0,0xec,0xe8,0xe4,0xf8,0xfc
};


//declaration des fonctions, il parait que ça aide
word nt2attraddr(word a);
void set_metatile(byte y, byte ch);
void clear_metatile(byte y);
void set_attr_entry(byte x, byte y, byte pal);
void put_attr_entries(word addr, byte length);
void generate_rng(void);
byte return_sprite_color(byte spr_index);
byte return_attribute_color(byte spr_index, byte spr_x, byte spr_y, byte * attr_table);
byte return_tile_attribute_color(byte color, byte spr_x, byte spr_y);
void update_boards(byte board_index);
byte check_board(byte board_index, byte x, byte y);
byte destroy_board(byte board_index);
byte fall_board(byte board_index);
void manage_point(byte index_player);
void build_field(void);
void setup_graphics(void);
void handle_controler_and_sprites(char i);
void update_next(byte i);
//music and sfx related
byte next_music_byte(void);
void play_music(void);
void start_music(const byte* music);
void play_rotation_sound(void);
void play_hit(byte hit); //pitch get higher with byte until reaching "bayoen !"
void play_puyo_fix(void); //when puyo is hitting ground, to be changed a bit tamed currently
void play_bayoen(void); // play bayoen sample
void fall_ojama(byte i); //fall ojama damage on the player field
void flush(byte i); // flush loser screen into under the play field

//music bloc definition
byte next_music_byte() {
  return *music_ptr++;
}

void play_music() {
  static byte chs = 0;
  if (music_ptr) {
    // run out duration timer yet?
    while (cur_duration == 0) {
      // fetch next byte in score
      byte note = next_music_byte();
      // is this a note?
      if ((note & 0x80) == 0) {
        // pulse plays higher notes, triangle for lower if it's free
        if (note >= BASS_NOTE || (chs & 4)) {
          int period = NOTE_TABLE[note & 63];
          // see which pulse generator is free
          if (!(chs & 1)) {
            APU_PULSE_DECAY(0, period, DUTY_25, 2, 10);
            chs |= 1;
          } else if (!(chs & 2)) {
            APU_PULSE_DECAY(1, period, DUTY_25, 2, 10);
            chs |= 2;
          }
        } else {
          int period = note_table_tri[note & 63];
          APU_TRIANGLE_LENGTH(period, 15);
          chs |= 4;
        }
      } else {
        // end of score marker
        if (note == 0xff)
          music_ptr = NULL;
        // set duration until next note
        cur_duration = note & 63;
        // reset channel used mask
        chs = 0;
      }
    }
    cur_duration--;
  }
}

void start_music(const byte* music) {
  music_ptr = music;
  cur_duration = 0;
}

//sfx
void play_rotation_sound()
{
  //APU_ENABLE(ENABLE_NOISE);
  APU_NOISE_SUSTAIN(15,2);
  APU_NOISE_DECAY(3,8,2);
}

void play_hit(byte hit)
{
  //APU_ENABLE(ENABLE_NOISE);
  //PULSE_CH0 is used by music, the sweep can be an issue
  //as it won't be deactivated automatically
  //so we use PULSE_CH1 for the moment
  switch (hit)
  {
    case 0:
      APU_PULSE_DECAY(PULSE_CH1, 2000, 192, 8, 1);
      break;
    case 1:
      APU_PULSE_DECAY(PULSE_CH1, 1750, 192, 8, 1);
      break;
    case 2:
      APU_PULSE_DECAY(PULSE_CH1, 1200, 192, 8, 1);
      break;
    case 3:
      APU_PULSE_DECAY(PULSE_CH1, 900, 192, 8, 1);
      break;
    case 4:
      APU_PULSE_DECAY(PULSE_CH1, 600, 192, 8, 1);
      break;
    case 5:
      APU_PULSE_DECAY(PULSE_CH1, 450, 192, 8, 1);
      break;
    case 6:
      APU_PULSE_DECAY(PULSE_CH1, 200, 192, 8, 1);
      break;
    case 7:
      APU_PULSE_DECAY(PULSE_CH1, 150, 192, 8, 1);
      break;
    case 8:
      APU_PULSE_DECAY(PULSE_CH1, 100, 192, 8, 1);
      break;
    default:
      play_bayoen();
      return;
  }
  
  //APU_PULSE_DECAY(PULSE_CH1, /*1121*/750+((hit-1)<<7), 192, 8, 1);
  APU_PULSE_SWEEP(PULSE_CH1,4,2,1);
  APU_NOISE_DECAY(0,8,3);
  //APU_PULSE_SWEEP_DISABLE(PULSE_CH0);
}

void play_puyo_fix()
{
  APU_TRIANGLE_LENGTH(497,13);
}


void play_bayoen()
{
  APU_ENABLE(0x1f);//DMC channel must be enabled each time a sample is played, because...
  APU_DMC_CONTROL(0x0E);//E 24khz, 0e sans int, 8e avec interruption
  APU_DMC_OUTPUT(0x3f); //3f value given by DMCConv.exe
  APU_DMC_address(SAMPLE_TEST);
  APU_DMC_length(0x75/*0xf*/);
}
//end of music bloc

// convert from nametable address to attribute table address
word nt2attraddr(word a) {
  return (a & 0x2c00) | 0x3c0 |
    ((a >> 4) & 0x38) | ((a >> 2) & 0x07);
}

// draw metatile into nametable buffers
// y is the metatile coordinate (row * 2)
// ch is the starting tile index in the pattern table
void set_metatile(byte y, byte ch) {
  ntbuf1[y*2] = ch;
  ntbuf1[y*2+1] = ch+1;
  ntbuf2[y*2] = ch+2;
  ntbuf2[y*2+1] = ch+3;
}

void clear_metatile(byte y)
{
  ntbuf1[y*2] = 0;
  ntbuf1[y*2+1] = 0;
  ntbuf2[y*2] = 0;
  ntbuf2[y*2+1] = 0;
}

// set attribute table entry in attrbuf
// x and y are metatile coordinates
// pal is the index to set
void set_attr_entry(byte x, byte y, byte pal) {
  if (y&1) pal <<= 4;
  if (x&1) pal <<= 2;
  attrbuf[y/2] |= pal;
}

// write attribute table buffer to vram buffer
/*void put_attr_entries(word addr) {
  byte i;
  for (i=0; i<PLAYROWS/4; i++) {
    VRAMBUF_PUT(addr, attrbuf[i], 0);
    addr += 8;
  }
  vrambuf_end();
}*/

void put_attr_entries(word addr, byte length) {
  byte i;
  for (i=0; i<length; ++i) {
    VRAMBUF_PUT(addr, attrbuf[i], 0);
    addr += 8;
  }
  vrambuf_end();
}

/*{pal:"nes",layout:"nes"}*/
const char PALETTE[32] = { 
  0x0D,			// screen color

  0x24,0x20,0x16,0x00,	// background palette 0
  0x39,0x20,0x11,0x00,	// background palette 1
  0x15,0x20,0x2A,0x00,	// background palette 2
  0x12,0x20,0x28,0x00,   // background palette 3

  0x23,0x20,0x16,0x00,	// sprite palette 0
  0x2C,0x20,0x11,0x00,	// sprite palette 1
  0x28,0x20,0x2A,0x00,	// sprite palette 2
  0x2D,0x20,0x28	// sprite palette 3
};

//generates the puyo that will be used during gameplay, they will be stock into puyo_list
void generate_rng()
{
  char nb_red = NBCOLORPOOL; // palette 0
  char nb_blue = NBCOLORPOOL; // palette 1
  char nb_green = NBCOLORPOOL; // palette 2 
  char nb_yellow = NBCOLORPOOL; // palette 3
  char tmp;
  byte i, j, redo;
  // puyo_list contains 64 (PUYOLISTLENGTH) char/8 bits info
  // each 8 bits contains 2 pairs as 1 puyo is a 2 bits color
  // as we have 4 colors palettes
  // the method used here is probably attrocious in term of optimization
  // but it should works.
  // we will be using rand8(), which is fast but...not very random
  rand();
  for (i = 0 ; i < PUYOLISTLENGTH ; ++i)
  {
    puyo_list[i] = 0; //reinit
    redo = 1; // loop until we get what we want;
    //get a number between 0 and 3
    for (j = 0 ; j < 4; ++j)
    {
      do
      {
        tmp = rand() & 3;
        switch (tmp)
        {
          case 0:
            if (nb_red > 0)
            {
              --nb_red;
              redo = 0;
              puyo_list[i] += (tmp);
            }
            break;
          case 1:
            if (nb_blue > 0)
            {
              --nb_blue;
              redo = 0;
              puyo_list[i] += (tmp << j*2);
            }
            break;
          case 2:
            if (nb_green > 0)
            {
              --nb_green;
              redo = 0;
              puyo_list[i] += (tmp << j*2);
            }
            break;
          case 3:
            if (nb_yellow > 0)
            {
              --nb_yellow;
              redo = 0;
              puyo_list[i] += (tmp << j*2);
            }
            break;
        }
      }while (redo);
    } 
  }
}

//return the color of the sprite given by the index in parameter
//OAM is a $200, each sprites uses 4 bytes, but we use metasprites of 4 bytes
//So metasprite 0 is at 200, 1 at 210,3 at 220 etc
//The attributes also contains the flip info, so mask it to 0x3 to only have color
byte return_sprite_color(byte spr_index)
{
  OAMSprite  *spr_ptr = (OAMSprite*)(0x200+16*spr_index);
  return (spr_ptr->attr & 0x3);
}

//based on sprite x/y position look for the bg attributes related to it
//find color value based on sprite index and returned the byte with the 4 tiles
//updated with sprite color
byte return_attribute_color(byte spr_index, byte spr_x, byte spr_y, byte * attr_table)
{
  //word addr = nt2attraddr(NTADR_A(spr_x,spr_y));
  byte attr_x = spr_x&0xfc;
  byte attr_y = spr_y&0xfc;
  byte attr;
  byte index;
  byte sprite_color = return_sprite_color(spr_index);
  byte mask = 3;
  //we must not override colors of the tiles around the one we change
  //We must determine were our meta sprite is located in the 4*4 metatile attributes
  //if x is odd it will be on the right, even left
  //if y is odd it will be on the bottom, even top
  //LSB is top left, MSB bottom right
  if (attr_y < spr_y)
  {
    mask <<= 4;
    sprite_color <<= 4;
  }
  if (attr_x < spr_x) 
  {
    mask <<= 2;
    sprite_color <<= 2;
  }
  // attribute position is y/2 + x/4 where y 2 LSB are 0
  index = (attr_y<<1) + (spr_x>>2);

  attr = attr_table[index];
  //let's erase the previous attributes for the intended position
  attr &= ~mask; //~ bitwise not, so we keep only bit outside of mask from attr
  attr += sprite_color;
  attr_table[index] = attr;
  return attr;
}

/* same as return_attribute_color but the color is in parameter, not get from sprite*/
byte return_tile_attribute_color(byte color, byte spr_x, byte spr_y)
{
 //word addr = nt2attraddr(NTADR_A(spr_x,spr_y));
  byte attr_x = spr_x&0xfc;
  byte attr_y = spr_y&0xfc;
  byte attr;
  byte index;
  byte mask = 3;
  //we must not override colors of the tiles around the one we change
  //We must determine were our meta sprite is located in the 4*4 metatile attributes
  //if x is odd it will be on the right, even left
  //if y is odd it will be on the bottom, even top
  //LSB is top left, MSB bottom right
  if (attr_y < spr_y)
  {
    mask <<= 4;
    color <<= 4;
  }
  if (attr_x < spr_x) 
  {
    mask <<= 2;
    color <<= 2;
  }
  // attribute position is y/2 + x/4 where y 2 LSB are 0
  index = (attr_y<<1) + (spr_x>>2);

  attr = attribute_table[index];
  //let's erase the previous attributes for the intended position
  attr &= ~mask; //~ bitwise not, so we keep only bit outside of mask from attr
  attr += color;
  attribute_table[index] = attr;
  return attr;
}

//Update the boards table, once the puyos have stop moveing, not  optimized :-S
//board_index must take 0 or 2
void update_boards(byte board_index)
{
  byte x,y;
  //char str[32];
  if (board_index == 0)
  { 
    //we must be careful not to erase the data for p2 table
    //column 0 is at 2 for actor_x[board_index]>>3, it gives us an offset, and we need to divide by 2 after to 
    //get the column number right
    x = ((actor_x[board_index]>>3) - 2) >> 1;
    y = ((actor_y[board_index]>>3)+1)>>1;
    //sprintf(str,"%d",(boards[x][y]&240));
    //vrambuf_put(NTADR_A(20,13),str,3);
    boards[x][y] = (boards[x][y]&240) + return_sprite_color(0);
   /* sprintf(str,"x:%d y:%d val:%d buf:%da",x , y, boards[x][y], return_sprite_color(0));
    vrambuf_put(NTADR_A(1,26),str,24);*/
    x = ((actor_x[board_index+1]>>3) - 2) >> 1;
    y = ((actor_y[board_index+1]>>3)+1)>>1;
   // sprintf(str,"%d",(boards[x][y]&240));
    //vrambuf_put(NTADR_A(20,14),str,3);
    boards[x][y] = (boards[x][y]&240) + return_sprite_color(1);
    /*sprintf(str,"x:%d y:%d val:%d buf:%da", x, y, boards[x][y], return_sprite_color(1));
    vrambuf_put(NTADR_A(1,27),str,24);*/

  }
  else
  {
    //we must be careful to not erase the ddata for p1 table
    //column 0 is at 18 for actor_x[board_index]>>3, it gives us an offset, and we need to divide by 2 after to 
    //get the column number  right
    x = ((actor_x[board_index]>>3) - 18) >> 1;
    y = ((actor_y[board_index]>>3)+1)>>1;
    boards[x][y] = (boards[x][y]&15) + (return_sprite_color(2) << 4);
    x = ((actor_x[board_index+1]>>3) - 18) >> 1;
    y = ((actor_y[board_index+1]>>3)+1)>>1;
    boards[x][y] = (boards[x][y]&15) + (return_sprite_color(3) << 4);
  }
}

// Look for puyo to destroy and flag them as such
byte check_board(byte board_index, byte x, byte y)
{
  static byte i, j, k, current_color; //static are faster, but they are keeping there value outside of context
  byte counter = 0, tmp_counter = 0;
  byte mask = 15, flag = 8, shift = 0;
  byte destruction = 0;
  //char str[32];
  
  if (board_index != 0)
  {
    shift = 4;
    mask <<= shift;
    flag <<= shift; //the 8th bit unused by color will serve as flag to check colors.
  }
  
  //to gain time we start from position of the last placed puyos
  //actor_x[board_index], actor_y[board_index],actor_x[board_index+1], actor_y[board_index+1],
  //x,y for each last puyo should be save somehere to gain time
  /*x = ((actor_x[board_index]>>3) - 2) >> 1;
  y = ((actor_y[board_index]>>3)+1)>>1;*/
  // First find puyo of the same color up, down, left, right to the current one.=, if no found exit
  // then move to the line above and below and check for a puyo of same color nearby
  // raise counter
  // until no more puyo left.
  // redo for next puyo
  // that way contrary to previous method we should not miss some boom.
  // Note : how to do when after destruction ?
  //k == current line above, k == current line below
  
  memset(tmp_boards,0,sizeof(tmp_boards));

  current_color = ((boards[x][y] & mask) >> shift);
  /*sprintf(str,"color:%d",current_color);
  vrambuf_put(NTADR_A(18,10),str,10);*/
  //tmp_boards contains flag of the currently looked color 
  tmp_boards[x][y] = flag;
  i = (x - 1); //byte are unsigned, so -1 = 255, we will not enter in the while if i < 0
  while ( i < 6 )
  {
    if ( tmp_boards[i][y] != flag)
    {
      if (current_color == ((boards[i][y] & mask) >> shift))
      {     
        tmp_boards[i][y] = flag;
        ++counter;
      }
      else
      {  
       /* i = 7; //no need to continue if not found
        continue;*/
        break;
      }
    }
    --i;
  }
  
  i = (x + 1);
  while ( i < 6 )
  {
    if ( tmp_boards[i][y] != flag)
    {
      if (current_color == ((boards[i][y] & mask) >> shift))
      {     
        tmp_boards[i][y] = flag;
        ++counter;
      }
      else
      {
        /*i = 7; //no need to continue if not found
        continue;*/
        break;
      }
    }
    ++i;
  }
  
  i = (y - 1);
  while ( i < 13 )
  {
    if ( tmp_boards[x][i] != flag)
    {
      if (current_color == ((boards[x][i] & mask) >> shift))
      {     
        tmp_boards[x][i] = flag;
        ++counter;
      } 
      else
      {
        //i = 14; //no need to continue if not found
        break;
      }
    }
    --i;
  }
  
  i = (y + 1);
  while ( i < 13 )
  {
    if ( tmp_boards[x][i] != flag)
    {
      if (current_color == ((boards[x][i] & mask) >> shift))
      {     
        tmp_boards[x][i] = flag;
        ++counter;
      } 
      else
      {
        //i = 14; //no need to continue if not found
        break;
      }
    }
    ++i;
  }
  //nothing found ? exit !
  if (counter == 0)
    return 0;
  
  //ok so we got something, now looking for more
  j = (y-1);
  //we go above, so we look below, left and right
  //we must do the line in both way (0 to 6 and 6 to 0) to avoid missing something
  while (j < 13)
  {
    /*
    for (i = 0; i < 6 ; ++i)
    {
      if (tmp_boards[i][j] != flag)
      {
        if ((current_color == ((boards[i][j] & mask) >> shift)))
        {
          if ((tmp_boards[i][j+1] == flag))
          {
            tmp_boards[i][j] = flag;
            ++counter;
            ++tmp_counter;
            continue;
          }
          else if (i > 0 && tmp_boards[i-1][j] == flag)
          {
            //look left
            tmp_boards[i][j] = flag;
            ++counter;
            ++tmp_counter;
            continue;
          }
          else if (i < 5 && tmp_boards[i+1][j] == flag)
          {
            //look right
            tmp_boards[i][j] = flag;
            ++counter;
            ++tmp_counter;
            continue;
          }
        }
      }
    }
    */
    //for not testing under or over the board
    k = j+1;
    //unlooped version
    //0
    if (tmp_boards[0][j] != flag && (current_color == ((boards[0][j] & mask) >> shift)) && 
        ( ((k!=13) ? (tmp_boards[0][k] == flag) : false) ||
         (tmp_boards[1][j] == flag)) )
    {
      tmp_boards[0][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //1
    if ( tmp_boards[1][j] != flag && (current_color == ((boards[1][j] & mask) >> shift)) && 
        ( ((k!=13) ? (tmp_boards[1][k] == flag) : false) ||
         (tmp_boards[0][j] == flag) ||
         (tmp_boards[2][j] == flag)) )
    {
      tmp_boards[1][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //2
    if ( tmp_boards[2][j] != flag &&  (current_color == ((boards[2][j] & mask) >> shift)) && 
        ( ((k!=13) ? (tmp_boards[2][k] == flag) : false) ||
         (tmp_boards[1][j] == flag) ||
         (tmp_boards[3][j] == flag)) )
    {
      tmp_boards[2][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //3
    if ( tmp_boards[3][j] != flag &&  (current_color == ((boards[3][j] & mask) >> shift)) && 
        ( ((k!=13) ? (tmp_boards[3][k] == flag) : false) ||
         (tmp_boards[2][j] == flag) ||
         (tmp_boards[4][j] == flag)) )
    {
      tmp_boards[3][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //4
    if ( tmp_boards[4][j] != flag &&  (current_color == ((boards[4][j] & mask) >> shift)) && 
        ( ((k!=13) ? (tmp_boards[4][k] == flag) : false) ||
         (tmp_boards[3][j] == flag) ||
         (tmp_boards[5][j] == flag)) )
    {
      tmp_boards[4][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //5
    if ( tmp_boards[5][j] != flag && (current_color == ((boards[5][j] & mask) >> shift)) && 
        ( ((k!=13) ? (tmp_boards[5][k] == flag) : false) ||
         (tmp_boards[4][j] == flag)))
    {
      tmp_boards[5][j] = flag;
      ++counter;
      ++tmp_counter;
    }
    
    //no need to go backward if nothing has been foun in the first loop
    if (tmp_counter != 0) 
    {
      /*
      for (i = 5; i < 6 ; --i)
      {
        //no need to look below as it has already been done in the previous loop
        if (tmp_boards[i][j] != flag)
        {
          if ((current_color == ((boards[i][j] & mask) >> shift)))
          {
            if (i > 0 && tmp_boards[i-1][j] == flag)
            {
              //look left
              tmp_boards[i][j] = flag;
              ++counter;
              continue;
            }
            else if (i < 5 && tmp_boards[i+1][j] == flag)
            {
              //look right
              tmp_boards[i][j] = flag;
              ++counter;
              continue;
            }
          }
        }
      }
      */
      
       //5 inutile on vient de le faire !
      /*if ( tmp_boards[5][j] != flag && (current_color == ((boards[5][j] & mask) >> shift)) && 
           (tmp_boards[4][j] == flag))
      {
        tmp_boards[5][j] = flag;
        ++counter;
      }*/
      
      //4
      if ( tmp_boards[4][j] != flag && (current_color == ((boards[4][j] & mask) >> shift)) && 
           ((tmp_boards[3][j] == flag) ||
            (tmp_boards[5][j] == flag)) )
      {
        tmp_boards[4][j] = flag;
        ++counter;
      }
      
      //3
      if ( tmp_boards[3][j] != flag && (current_color == ((boards[3][j] & mask) >> shift)) && 
           ((tmp_boards[2][j] == flag) ||
            (tmp_boards[4][j] == flag)) )
      {
        tmp_boards[3][j] = flag;
        ++counter;
      }
      
      //2
      if ( tmp_boards[2][j] != flag && (current_color == ((boards[2][j] & mask) >> shift)) && 
           ((tmp_boards[1][j] == flag) ||
            (tmp_boards[3][j] == flag)) )
      {
        tmp_boards[2][j] = flag;
        ++counter;
      }
      
      //1
      if ( tmp_boards[1][j] != flag && (current_color == ((boards[1][j] & mask) >> shift)) && 
           ((tmp_boards[0][j] == flag) ||
            (tmp_boards[2][j] == flag)) )
      {
        tmp_boards[1][j] = flag;
        ++counter;
      }
      
       //0
      if ( tmp_boards[0][j] != flag && (current_color == ((boards[0][j] & mask) >> shift)) && 
           ((tmp_boards[1][j] == flag)) )
      {
        tmp_boards[0][j] = flag;
        ++counter;
      } 
      
    }
    tmp_counter = 0;
    --j; //going above is getting lower j
  }
  
  j = y+1;
  //we go below so we look above
  while (j < 13)
  {
    /*
    for (i = 0; i < 6 ; ++i)
    {
      if (tmp_boards[i][j] != flag)
      {
        if ((current_color == ((boards[i][j] & mask) >> shift)))
        {
          if ((tmp_boards[i][j-1] == flag))
          {
            tmp_boards[i][j] = flag;
            ++counter;
            ++tmp_counter;
            continue;
          }
          else if (i > 0 && tmp_boards[i-1][j] == flag)
          {
            //look left
            tmp_boards[i][j] = flag;
            ++counter;
            ++tmp_counter;
            continue;
          }
          else if (i < 5 && tmp_boards[i+1][j] == flag)
          {
            //look right
            tmp_boards[i][j] = flag;
            ++counter;
            ++tmp_counter;
            continue;
          }
        }
      }
    }*/
    //for not testing under or over the board
    k = j-1;
    
    //unlooped version
    //0
    if (tmp_boards[0][j] != flag && (current_color == ((boards[0][j] & mask) >> shift)) && 
        (((k<13) ? (tmp_boards[0][k] == flag) : false) ||
         (tmp_boards[1][j] == flag)) )
    {
      tmp_boards[0][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //1
    if ( tmp_boards[1][j] != flag && (current_color == ((boards[1][j] & mask) >> shift)) && 
        (((k<13) ? (tmp_boards[1][k] == flag) : false) ||
         (tmp_boards[0][j] == flag) ||
         (tmp_boards[2][j] == flag)) )
    {
      tmp_boards[1][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //2
    if ( tmp_boards[2][j] != flag &&  (current_color == ((boards[2][j] & mask) >> shift)) && 
        (((k<13) ? (tmp_boards[2][k] == flag) : false) ||
         (tmp_boards[1][j] == flag) ||
         (tmp_boards[3][j] == flag)) )
    {
      tmp_boards[2][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //3
    if ( tmp_boards[3][j] != flag &&  (current_color == ((boards[3][j] & mask) >> shift)) && 
        (((k<13) ? (tmp_boards[3][k] == flag) : false) ||
         (tmp_boards[2][j] == flag) ||
         (tmp_boards[4][j] == flag)) )
    {
      tmp_boards[3][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //4
    if ( tmp_boards[4][j] != flag &&  (current_color == ((boards[4][j] & mask) >> shift)) && 
        (((k<13) ? (tmp_boards[4][k] == flag) : false) ||
         (tmp_boards[3][j] == flag) ||
         (tmp_boards[5][j] == flag)) )
    {
      tmp_boards[4][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    //5
    if ( tmp_boards[5][j] != flag && (current_color == ((boards[5][j] & mask) >> shift)) && 
        ( ((k<13) ? (tmp_boards[5][k] == flag) : false) ||
         (tmp_boards[4][j] == flag)))
    {
      tmp_boards[5][j] = flag;
      ++counter;
      ++tmp_counter;
    }

    if (tmp_counter != 0)
    {
      /*
      for (i = 5; i < 6 ; --i)
      {
        //no need to look below as it has already been done in the previous loop
        if (tmp_boards[i][j] != flag)
        {
          if ((current_color == ((boards[i][j] & mask) >> shift)))
          {
            if (i > 0 && tmp_boards[i-1][j] == flag)
            {
              //look left
              tmp_boards[i][j] = flag;
              ++counter;
              continue;
            }
            else if (i < 5 && tmp_boards[i+1][j] == flag)
            {
              //look right
              tmp_boards[i][j] = flag;
              ++counter;
              continue;
            }
          }
        }
      }
      */
      
      //5 useless, same as last from previous "loop"
      /*if ( tmp_boards[5][j] != flag && (current_color == ((boards[5][j] & mask) >> shift)) && 
           (tmp_boards[4][j] == flag))
      {
        tmp_boards[5][j] = flag;
        ++counter;
      }*/
      
      //4
      if ( tmp_boards[4][j] != flag && (current_color == ((boards[4][j] & mask) >> shift)) && 
           ((tmp_boards[3][j] == flag) ||
            (tmp_boards[5][j] == flag)) )
      {
        tmp_boards[4][j] = flag;
        ++counter;
      }
      
      //3
      if ( tmp_boards[3][j] != flag && (current_color == ((boards[3][j] & mask) >> shift)) && 
           ((tmp_boards[2][j] == flag) ||
            (tmp_boards[4][j] == flag)) )
      {
        tmp_boards[3][j] = flag;
        ++counter;
      }
      
      //2
      if ( tmp_boards[2][j] != flag && (current_color == ((boards[2][j] & mask) >> shift)) && 
           ((tmp_boards[1][j] == flag) ||
            (tmp_boards[3][j] == flag)) )
      {
        tmp_boards[2][j] = flag;
        ++counter;
      }
      
      //1
      if ( tmp_boards[1][j] != flag && (current_color == ((boards[1][j] & mask) >> shift)) && 
           ((tmp_boards[0][j] == flag) ||
            (tmp_boards[2][j] == flag)) )
      {
        tmp_boards[1][j] = flag;
        ++counter;
      }
      
       //0
      if ( tmp_boards[0][j] != flag && (current_color == ((boards[0][j] & mask) >> shift)) && 
           ((tmp_boards[1][j] == flag)) )
      {
        tmp_boards[0][j] = flag;
        ++counter;
      } 
    }
    tmp_counter = 0;
    ++j; //going below is getting higher j
  }
  
  //we started from 0, so at 3 we have 4 to erase
  if (counter >= 3)
  {
    //update the variable for point counting
    nb_puyos_destroyed[board_index] += (counter + 1); //how many puyos are destroyed on that hit
    // LSB p1, MSB p2, bit mask at 1 for each color present in the hit. bit 0 red, bit 1 blue, bit 2 green, 3 yellow
    mask_color_destroyed |= (1 << shift) << current_color;  
    nb_group[board_index] += (counter + 1) - 4;//if the group is over 4 puyos add the part over in this variable.

    //copy flag to boards
    for (i = 0; i < 6; ++i)
    {
      for (j = 12 ; j <= 12 ; --j)
      {
        if ( tmp_boards[i][j] == flag)
        {
          boards[i][j] |= flag;
          //tmp_boards[i][j] = 0;
          /*sprintf(str,"%d %d",i,j);
          vrambuf_put(NTADR_A(18,4+destruction),str,5);*/
          ++destruction;
        }
      }
    }
  }
  return destruction;
}

//puyo visual destroying after check_board
byte destroy_board(byte board_index)
{
  byte i, j/*, current_color*/;
  byte counter = 0, tmp_line = 0;
  byte mask = 15, invmask = 240, flag = 8, shift = 0;
  byte destruction = 0;
  byte tmp_counter;
  register word addr;
  //char str[32];
  
  //memset(tmp_boards,0,sizeof(tmp_boards));
  if (board_index != 0)
  {
    shift = 4;
    mask <<= shift;
    invmask >>= shift;
    flag <<= shift; //the 8th bit unused by color will serve as flag to check colors.
    tmp_counter = step_p2_counter;
  }
  else
    tmp_counter = step_p1_counter;
  
  //step 0 we change the puyo to puyo_pop => e0
  if (tmp_counter < 6)
  {
    memset(ntbuf1, 0, sizeof(ntbuf1));
    memset(ntbuf2, 0, sizeof(ntbuf2));
    memset(attrbuf, 0, sizeof(attrbuf));

    set_metatile(0,0xe0); //0xe0 == puyo_pop
    /*for (i = 0; i < 6 ; ++i)
    {*/
    for (j = 0; j < 13 ; ++j)
    {
      if ((boards[tmp_counter][j] & flag) > 0)
      {
        //(i+1)<<1 à l'air ok, y on y est pas encore
        //addr = NTADR_A((i+1)<<1, j *2 );//?????
        addr = NTADR_A(((tmp_counter)*2)+2, j *2 );//?????
        vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
        vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);
        /*addr = NTADR_A(i, (j)+2);
          vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
          vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);*/
        //sujet traité, on zappe le flag
        boards[tmp_counter][j] -= flag;
        //on change le board pour puyo_pop
        //PUYO_POP
        //(boards[x][y]&15) + (return_sprite_color(3) << 4);
        boards[tmp_counter][j] = (boards[tmp_counter][j] & invmask) + (PUYO_POP << shift);
        //we will reuse the flag for destruction
        boards[tmp_counter][j] += flag;
        tmp_line=j;
        /*sprintf(str,"%d", j);
          vrambuf_put(NTADR_A(18,j*2),str,2);*/
      }
      //}
    }
    
  }
  //step 1 we change the puyo_pop to nothing
  if (tmp_counter >= 12)
  {
    memset(ntbuf1, 0, sizeof(ntbuf1));
    memset(ntbuf2, 0, sizeof(ntbuf2));
    memset(attrbuf, 0, sizeof(attrbuf));

    clear_metatile(0);
    i = tmp_counter%12;
    
   /* for (i = 0; i < 6 ; ++i)
    {*/
    for (j = 0; j < 13 ; ++j)
    {
      if ((boards[i][j] & flag) > 0)
      {
        addr = NTADR_A(((i)*2)+2, j *2 );
        vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
        vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);
        //sujet traité, on zappe le flag
        boards[i][j] -= flag;
        //on change le board pour EMPTY
        boards[i][j] = (boards[i][j] & invmask) + (EMPTY << shift);
      }
    }
   // }
    if (tmp_counter == 18)
    {
      //TODO à corriger pour P2 !
      step_p1 = POINT;
      step_p1_counter = 255;
    }
  }

  ++step_p1_counter;
  return 0;
}

/*puyo falling*/
byte fall_board(byte board_index)
{
  //TODO !
  //column_height doit être baissé (enfin montée, 0 est en haut) de 16 (+=16) à chaque fois qu'on descend un truc
  //on part d'en haut, de la première colonne, et on descend
  //step_p1_counter donne la colonne
  //on reconstruit d'abord la colonne sans trou dans boards[x][y]
  //ensuite on redessine toute la colonne dans le buffer.
  //si pas de changement on ne fait rien pour gagner en temps de calcul !
  byte j, j2;
  byte can_fall = 0, previous_empty = 0, puyo_found = 0;
  byte smask = 7, sinvmask = 112, mask = 15, invmask=240, flag = 8, shift = 0; /*on ne veut pas du flag pour les masques*/
  byte attr_x_shift = 1;
  byte fall = 0;
  byte tmp_counter = 0, tmp_counter_2 = 0;
  register word addr;
  //char str[32];
  
  //memset(tmp_boards,0,sizeof(tmp_boards));
  if (board_index != 0)
  {
    shift = 4;
    mask <<= shift;
    smask <<= shift;
    invmask >>= shift;
    flag <<= shift; //the 8th bit unused by color will serve as flag to check colors.
    attr_x_shift = 9;
    tmp_counter = step_p2_counter%6;
    /*if (tmp_counter > 5)
      return 0;*/
  }
  else
  { 
    tmp_counter = step_p1_counter%6;
    /*if (tmp_counter > 5)
      return 0;*/
  }
  
  for (j = 0 ; j < 13 ; ++j)
  {
    if (can_fall != 1 && ( (boards[tmp_counter][j] & smask)) >> shift != EMPTY)
    {
      puyo_found = j;// if no puyo are found then the column is empty=> need to reset height
      //as long as no puyo is found, there is nothing to get down
      can_fall = 1;
      if (j+1 < 13)
        ++j;  
    }

    if (can_fall == 1 && ( (boards[tmp_counter][j] & smask) >> shift) == EMPTY)
    {
      //this is where things get interesting, lets move everything down.
      //we start from j and get up to avoid overwriting values
      for (j2 = j ; j2 >= previous_empty && j2 < 255 ; --j2)
      {
        if (j2 == 0) 
          boards[tmp_counter][j2] = (boards[tmp_counter][j2] & invmask) + (EMPTY << shift);
        else
          boards[tmp_counter][j2] = (boards[tmp_counter][j2] & invmask) + (boards[tmp_counter][j2-1] & mask);  
      }
      fall = 1;
      /*sprintf(str,"F %d", tmp_counter);
        vrambuf_put(NTADR_A(16,15+tmp_counter),str,8);*/

      //careful we wan't to only fall of 1 puyo height per cycle !
      //So we keep the position of the last element that has falled so top there
      previous_empty = j+1;
      can_fall = 0;
    }
  }
 
  if (fall == 1)
  {
    //If we got a fall we reset the counter, then 
    if (board_index != 0)
    {
      step_p2_counter = tmp_counter;
      //As it fall the height of the column must be lowered:
      column_height[tmp_counter+6] +=16;
      tmp_counter_2 = tmp_counter + /*6*/8;
    }
    else
    {
      step_p1_counter = tmp_counter;
      column_height[tmp_counter] +=16;
      tmp_counter_2 = tmp_counter;
    }
    //redraw the column through buffer
    memset(ntbuf1, 0, sizeof(ntbuf1));
    memset(ntbuf2, 0, sizeof(ntbuf2));
    memset(attrbuf, 0, sizeof(attrbuf));
    //we start at 1 as we don't want to modify the ceiling
    for (j = 1; j < 13 ; ++j)
    {
      switch ((boards[tmp_counter][j] & mask) >> shift)
      {// HERE !!!!!!! tmp_counter ? manque + 6 pour p2
        case EMPTY:
          clear_metatile(j-1);
          attrbuf[j>>1] = return_tile_attribute_color(2,(tmp_counter_2+1)*2,j*2);
          break;
        case OJAMA:
          set_metatile(j-1,0xdc);
          attrbuf[j>>1] = return_tile_attribute_color(0,(tmp_counter_2+1)*2,j*2);
          break;
        case PUYO_RED:
          set_metatile(j-1,0xd8);
          attrbuf[j>>1] = return_tile_attribute_color(0,(tmp_counter_2+1)*2,j*2);
          break;
        case PUYO_BLUE:
          set_metatile(j-1,0xd8);
          attrbuf[j>>1] = return_tile_attribute_color(1,(tmp_counter_2+1)*2,j*2);
          break;
        case PUYO_GREEN:
          set_metatile(j-1,0xd8);
          attrbuf[j>>1] = return_tile_attribute_color(2,(tmp_counter_2+1)*2,j*2);
          break;
        case PUYO_YELLOW:
          set_metatile(j-1,0xd8);
          attrbuf[j>>1] = return_tile_attribute_color(3,(tmp_counter_2+1)*2,j*2);
          break;
      }
    } 
   
    //remplir les buffers nt et attr et ensuite faire le put !
    addr = NTADR_A(((tmp_counter_2)*2)+2, 2 );// le buffer contient toute la hauteur de notre tableau ! on commence en haut, donc 2
    vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 24);
    vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 24);
    put_attr_entries((nt2attraddr(addr)), 7);
    
  }
  else
  {
    if (board_index != 0)
    {
      tmp_counter_2 = tmp_counter + 6;
    }
    else
    {
      tmp_counter_2 = tmp_counter;
    }
    //if something "fall" the counter is always reset to its 0 to 5 equivalent
    //so if nothing fall and we reach 11 (5th column) then a full "loop" as been done and we can continue
    if (puyo_found == 0)
    {  
      column_height[tmp_counter_2] = 190;
    }
    else
    {
      //if puyo_found kept the height of the first puyo found, with no fall
      //this is the heighest in the stack.
      column_height[tmp_counter_2] = ((puyo_found-1)*16) -2;
    }
    
    if (board_index == 0)
    {
      if (step_p1_counter == 11)
      {
        if (step_p1 == FALL)
        {
          step_p1 = CHECK_ALL;
          step_p1_counter = 255;
        }
        else
        {
          //FALL_OJAMA case, we go to show_next,
          step_p1 = SHOW_NEXT;
          step_p1_counter = 0;
          step_ojama_fall[0] = 0;
        }
      }
    }
    else
    {
      if (step_p2_counter == 11)
      {
        if (step_p2 == FALL)
        {
          step_p2 = CHECK_ALL;
          step_p2_counter = 255;
        }
        else
        {
          //FALL_OJAMA case, we go to show_next,
          step_p2 = SHOW_NEXT;
          step_p2_counter = 0;
          step_ojama_fall[1] = 0;
        }
      }
    }
  }
  
  if (board_index != 0)
    ++step_p2_counter;
  else
    ++step_p1_counter;

  return board_index;
}

// Calculate the point and update the score plus the ojama on top of opponent board
// 2 steps : first score calculation plus display under player board
// 2 tile calculation base on ojamas[] and display
//doing both at the same time makes the screen jump...
void manage_point(byte index_player)
{
  //based on this formula: https://www.bayoen.fr/wiki/Tableau_des_dommages
  //dommage hit = (10*nb_puyos_destroyed)*(hit_power + color_bonus + group_bonus)
  char str[6];
  byte tmp_mask = 0, i = 0;
  unsigned long int tmp_score = 0;
  register word addr;
  
  if ((index_player == 0)  ? (step_p1_counter == 0):(step_p2_counter == 0))
  {
    //hit power
    tmp_score = (nb_hit[index_player] <= 3) ? ((nb_hit[index_player]-1) << 3) : ((nb_hit[index_player]-3) << 5);

    //color_bonus
    //first get colors for current player
    tmp_mask = mask_color_destroyed & ((index_player == 0) ? 0xf : 0xf0);

    //then get nb of colors used from the mask by bitshift, substract 1 and multiply by 3
    tmp_score += (((tmp_mask & 1) + ((tmp_mask & 2) >> 1) + ((tmp_mask & 4) >> 2) + ((tmp_mask & 8) >> 3)) - 1) * 3;


    // group_bonus
    if ( nb_group[index_player] > 0 )
    {
      tmp_score += ( (nb_group[index_player] < 7) ? (nb_group[index_player] + 1) : 10 );
    }

    //you need to raise the score if bonus are null, to avoid multiply by 0
    if (tmp_score == 0)
      tmp_score = 1;

    //Now the disappearing puyos
    tmp_score = tmp_score * ((unsigned long) nb_puyos_destroyed[index_player] * 10);

    score[index_player] += tmp_score;

    //WIP add the opponent ojama removal from current player stack !
    if (index_player == 0)
    {
      ojamas[2] += tmp_score;
      if (ojamas[0] > 0)
      {  
        ojamas[0] = (ojamas[0] - tmp_score > ojamas[0] ) ? 0 : ojamas[0] - tmp_score ;
      }
    }
    else
    {
      ojamas[0] += tmp_score;
      if (ojamas[2] > 0)
      {  
        ojamas[2] = (ojamas[2] - tmp_score > ojamas[2] ) ? 0 : ojamas[2] - tmp_score ;
      }
    }

    //TODO warikomi not handled yet
    sprintf(str,"Hit:%2d", nb_hit[index_player]);
    addr = NTADR_A(2,26);
    vrambuf_put(addr,str,6);
    sprintf(str,"%6lu", score[index_player]);
    addr = NTADR_A(8,27);
    vrambuf_put(addr,str,6);
    
    //play hit sound
    play_hit(nb_hit[index_player]);
    
    //reinit value for next compute
    nb_puyos_destroyed[index_player] = 0;
    mask_color_destroyed = mask_color_destroyed & 0xF0;
    nb_group[index_player] = 0;
  }
  else
  {
    //display damages
    //note :at some point we will have to deal with to much things updated simultaneously
    memset(ntbuf1, 0, sizeof(ntbuf1));
    memset(ntbuf2, 0, sizeof(ntbuf2));
    memset(attrbuf, 0, sizeof(attrbuf));
    //the number of ojama depends of the score
    //see https://www.bayoen.fr/wiki/Tableau_des_dommages
    //would be neater to put addresses into an enum...
    //1:    0xfc   ojama
    //6:    0xf8   bug ojama
    //30:   0xe4   rock
    //180:  0xe8   tilted rock
    //360:  0xec   star
    //720:  0xf0   crown
    //1440: 0xf4   comet
    
    //first let's get our score divided by 70
    tmp_score = ojamas[(index_player == 0 ? 2 : 0)] / 70;
    index_player = 0;
    //let's cheat, setup everything as ojamaless tile
    memset(str,0xc4, sizeof(str));
    
    for ( i = 0; i < 7  && index_player < 6 ; ++i)
    {
      //we go from higher score to lowest, checking the rest.
      if (tmp_score / damageList[i] > 0 )
      {
        //we use our previously declared str to store the address of the tile
        //we use byte_mask because as str it is there, avoidinf declaring something else
        //index_is reused too !
        for (tmp_mask = 0; tmp_mask < (tmp_score/damageList[i]) && index_player < 6 ; ++tmp_mask)
        {
          str[index_player] = damageTile[i];
          ++index_player;
        }   
      }
      tmp_score %= damageList[i];     
    }

    set_metatile(0,str[0]);
    attrbuf[0] = return_tile_attribute_color(0,20,0);
    addr = NTADR_A(18, 0);// le buffer contient toute la hauteur de notre tableau ! on commence en haut, donc 2
    //si je ne mets pas le VRAMBUF_VERT la tile n'est pas bien présentée...
    //ce qui oblige à faire 6 appels, il faudra que je me plonge dans cette histoire
    //plus profondément à un moment.
    vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
    vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);

    set_metatile(0,str[1]);
    attrbuf[0] = return_tile_attribute_color(0,20,0);
    addr = NTADR_A(20, 0);
    vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
    vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);

    set_metatile(0,str[2]);
    attrbuf[0] = return_tile_attribute_color(0,20,0);
    addr = NTADR_A(22, 0);
    vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
    vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);

    set_metatile(0,str[3]);
    attrbuf[0] = return_tile_attribute_color(0,20,0);
    addr = NTADR_A(24, 0);
    vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
    vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);

    set_metatile(0,str[4]);
    attrbuf[0] = return_tile_attribute_color(0,20,0);
    addr = NTADR_A(26, 0);
    vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
    vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);

    set_metatile(0,str[5]);
    attrbuf[0] = return_tile_attribute_color(0,20,0);
    addr = NTADR_A(28, 0);
    vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
    vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);

    put_attr_entries((nt2attraddr(addr)),6);
  }
}

//fall ojama damage on the player field
void fall_ojama(byte board_index)
{
  /* Conditions :
  The other player must be in "PLAY" step when the step_counter of fall_ojama is at 0
  We can only fall 5 rows at a time, then it goes to SHOW_NEXT and player continue to play
  The cell [2][1] must be free, if not game over
  The ojama score should be superior to 0
  */
  
  byte smask = 7, sinvmask = 112, mask = 15, invmask=240, flag = 8, shift = 0; /*on ne veut pas du flag pour les masques*/
  byte attr_x_shift = 1;
  byte fall = 0, i = 0, top_line_space = 0;
  byte tmp_counter, opponent_status, player_status;
  //register word addr;
  //char str[32];
  
  //memset(tmp_boards,0,sizeof(tmp_boards));
  if (board_index != 0)
  {
    shift = 4;
    mask <<= shift;
    invmask >>= shift;
    flag <<= shift; //the 8th bit unused by color will serve as flag to check colors.
    attr_x_shift = 9;
    tmp_counter = step_p2_counter;
    opponent_status = step_p1;
    player_status = step_p2;
  }
  else
  { 
    tmp_counter = step_p1_counter;
    opponent_status = step_p2;
  }
  
  if ((step_ojama_fall[board_index] == 0 && opponent_status != PLAY) /*|| ojama[board_index<<1] == 0 || tmp_counter == 5*/)
  {
    //inutile de continuer on passe à SHOW_NEXT
    if (board_index == 0)
    {
      step_p1 = SHOW_NEXT;
      step_p1_counter = 0;
    }
    else
    {
      step_p2 = SHOW_NEXT;
      step_p2_counter = 0;
    }   
    return;
  }
  
  //add a line max of ojama on row 
  if ( (step_ojama_fall[board_index] < 5) && (ojamas[board_index<<1] >= 70))
  {
    if ( ojamas[board_index<<1] >= 420)
    {
      // over 70*6, 420, a full line can be added
      for (i = 0; i < 6; ++i)
      {
        if ( (boards[i][0] & mask >> shift) == EMPTY)
        {
          boards[i][0] = (boards[i][0] & invmask) + (OJAMA << shift);
          if ( (ojamas[board_index<<1] - 70) < ojamas[board_index<<1]) //if not inferior then less than 70 !
          { 
            ojamas[board_index<<1]-= 70;
          }
          else
          {
            ojamas[board_index<<1] = 0;
            break;//no points, no need to continue
          }
        }
      }
    }
    else
    {
      //less than a line, we have to randomize the popping
      //look for empty spots on the top hidden line:
      top_line_space = 0;
      for (i = 0; i < 6; ++i )
      {
        if ((boards[i][0] & mask >> shift) == EMPTY)
        {
          ++top_line_space;
        } 
      }
      if (top_line_space > 0)
      {
        if (top_line_space > ojamas[board_index<<1] / 70)
        {
          i = 0;
          //more space than ojama, we randomize the fall
          while (ojamas[board_index<<1] >= 70)
          {
            if ((boards[i][0] & mask >> shift) == EMPTY && (rand8() & 1))
            {
              //boards[i][0] |= (OJAMA << shift);
              boards[i][0] = (boards[i][0] & invmask) + (OJAMA << shift);
              ojamas[board_index<<1] -= 70;
            }
            ++i;
            i = i%6;//to loop
          }
        }
        else
        {
          //less space than ojama, we fill every holes., the remaining ojamas will fall at next step
          for (i = 0; i < 6; ++i )
          {
            if ((boards[i][0] & mask >> shift) == EMPTY)
            {
              //boards[i][0] |= (OJAMA << shift);
              boards[i][0] = (boards[i][0] & invmask) + (OJAMA << shift);
              ojamas[board_index<<1] -= 70;
            } 
          }
        }
      }
      
    }
    step_ojama_fall[board_index]++;
  }
  
  //make them fall a line, if fall board is not moving, then it will go to "CHECK_ALL" at the end of fall_board
  fall_board(board_index);
 
  return;
}

// flush loser screen into under the play field
void flush(byte board_index)
{
  board_index++;
  return;
}

//update the color of the next pair to come between fields
void update_next(byte i)
{
  // current position is p1_puyo_list_index, 
  //We have to remember that one byte contains 4 colors/puyo (2 bits per color)
  //we move only by 2 however
  
  // puyo_list       p1_puyo_list_index
  // (p1_puyo_list_index>>1) retourne le bon index puisqu'on a 4 paires par index
  // ensuite on décale sur le bon élément de l'index 
  // 2 bits pour chaque puyo=> on décale à droite (0<<0, 1<<2, 2<<4,3<<6)
  // et on fait & 3 pour ne garder que les 2 premiers bits
  
  //puyoSeq[(puyo_list[(p1_puyo_list_index>>1)]>>((((p1_puyo_list_index%2)*2)+i)*2))&3]);

  //I still quite don't get how this tile buffering fuctions works
  //So I do it like..that, and it's ugly.
  memset(attrbuf, 0, sizeof(attrbuf));
  attrbuf[0] = return_tile_attribute_color((puyo_list[((p1_puyo_list_index+1)>>1)]>>(((((p1_puyo_list_index+1)%2)*2)+0)*2))&3,14+(i<<1),4); 
  put_attr_entries((nt2attraddr( NTADR_A(14+(i<<1), 4 ))), 1);
  attrbuf[0] = return_tile_attribute_color((puyo_list[((p1_puyo_list_index+1)>>1)]>>(((((p1_puyo_list_index+1)%2)*2)+1)*2))&3,14+(i<<1),6); 
  put_attr_entries((nt2attraddr( NTADR_A(14+(i<<1), 6 ))), 1);
  //attrbuf[0] = return_tile_attribute_color(0,14+(i<<1),8); 
  //put_attr_entries((nt2attraddr( NTADR_A(14+(i<<1), 8 ))), 1);
  attrbuf[0] = return_tile_attribute_color((puyo_list[((p1_puyo_list_index+2)>>1)]>>(((((p1_puyo_list_index+2)%2)*2)+0)*2))&3,14+(i<<1),10);
  put_attr_entries((nt2attraddr( NTADR_A(14+(i<<1), 10 ))), 1);
  attrbuf[0] = return_tile_attribute_color((puyo_list[((p1_puyo_list_index+2)>>1)]>>(((((p1_puyo_list_index+2)%2)*2)+1)*2))&3,14+(i<<1),12);
  put_attr_entries((nt2attraddr( NTADR_A(14+(i<<1), 12 ))), 1);; 
  return;
}


void build_field()
{
  //register word addr;
  //byte i, x, y;
  byte x, y;
  //Filling up boards with EMPTY
  for (x = 0; x < 6; ++x)
  {
    for (y = 0; y < 13; ++y)
    {
      boards[x][y] = EMPTY + (EMPTY << 4);
      tmp_boards[x][y] = 0;
    }
  }
  
  //initialize attribute table to 0;
  memset(attribute_table,0,sizeof(attribute_table));
  for (x = 0; x < PLAYCOLUMNS; x+=2)
  {
    if (x == 0 || x == 30)
    {
      for (y = 0; y < PLAYROWS; y+=2)
      {
        vram_adr(NTADR_A(x,y));
        vram_put(0xc4);
        vram_put(0xc6);
        vram_adr(NTADR_A(x,y+1));
        vram_put(0xc5);
        vram_put(0xc7);
      }
    }
    else if (/* x == 8 ||x == 9 || x == 10 ||x == 11 || x == 12 || x == 13 ||*/ x == 14 || x == 15) //14 et 15
    {/* il faudra ici mettre les puyo à venir !*/
      for (y = 0; y < PLAYROWS; y+=2)
      {
        if ( (y >= 4 && y <= 6) || (y >= 10 && y <= 12) )
        {
          vram_adr(NTADR_A(x,y));
          vram_put(0xc8);
          vram_put(0xca);
          vram_adr(NTADR_A(x,y+1));
          vram_put(0xc9);
          vram_put(0xcb);
        }
        else
        {
          vram_adr(NTADR_A(x,y));
          vram_put(0xc4);
          vram_put(0xc6);
          vram_adr(NTADR_A(x,y+1));
          vram_put(0xc5);
          vram_put(0xc7);
        }
      }
    }
    else if (x == 16 || x == 17/* || x == 18 || x == 19 || x == 20*/) // 16 et 17
    {
      for (y = 0; y < PLAYROWS; y+=2)
      {
       if ( (y >= 4 && y <= 6) || (y >= 10 && y <= 12) )
        {
          vram_adr(NTADR_A(x,y));
          vram_put(0xc8);
          vram_put(0xca);
          vram_adr(NTADR_A(x,y+1));
          vram_put(0xc9);
          vram_put(0xcb);
        }
        else
        {
          vram_adr(NTADR_A(x,y));
          vram_put(0xc4);
          vram_put(0xc6);
          vram_adr(NTADR_A(x,y+1));
          vram_put(0xc5);
          vram_put(0xc7);
        }
      }
    }
    else
    {//le haut/ bas de l'air de jeu
      vram_adr(NTADR_A(x,0));
      vram_put(0xc4);
      vram_put(0xc6);
      vram_adr(NTADR_A(x,1));
      vram_put(0xc5);
      vram_put(0xc7);
      vram_adr(NTADR_A(x,PLAYROWS-4));
      vram_put(0xc4);
      vram_put(0xc6);
      vram_adr(NTADR_A(x,PLAYROWS-3));
      vram_put(0xc5);
      vram_put(0xc7);
      vram_adr(NTADR_A(x,PLAYROWS-2));
      vram_put(0xc4);
      vram_put(0xc6);
      vram_adr(NTADR_A(x,PLAYROWS-1));
      vram_put(0xc5);
      vram_put(0xc7);
    }
    
  }
  //colonne 0 et 31 sont pleines 
  //On peut pas mettre plus de 3 colonnes dans le buffer...
  /*
  vrambuf_clear();
  memset(ntbuf1, 0, sizeof(ntbuf1));
  memset(ntbuf2, 0, sizeof(ntbuf2));
  for (i = 0; i < PLAYROWS/2 - 1; i++)
  {
    set_metatile(i,0xc4);
  }
  addr = NTADR_A(0, 0);
  vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, PLAYROWS);
  vrambuf_put((addr+1)|VRAMBUF_VERT, ntbuf2, PLAYROWS);
  //vrambuf_flush();
  addr = NTADR_A(2, 0);
  vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, PLAYROWS);
  //vrambuf_put((addr+1)|VRAMBUF_VERT, ntbuf2, PLAYROWS);
  */
  
  // copy attribute table from PRG ROM to VRAM
  vram_write(attribute_table, sizeof(attribute_table));
}

// setup PPU and tables
void setup_graphics() {
  // clear sprites
  oam_clear();
   // clear sprites
  oam_hide_rest(0);
  // set palette colors
  pal_all(PALETTE);
   // clear vram buffer
  vrambuf_clear();
  set_vram_update(updbuf);
  seg_palette = rand8() & 3;
  seg_char = 0xe0;
}

void handle_controler_and_sprites(char i)
{
  pad = pad_poll(i);

  //update status of controller memory
  if (previous_pad[i]&PAD_LEFT && pad&PAD_LEFT)
    ++input_delay_PAD_LEFT[i];
  else
    input_delay_PAD_LEFT[i] = 0;
  if (previous_pad[i]&PAD_RIGHT && pad&PAD_RIGHT)
    ++input_delay_PAD_RIGHT[i];
  else
    input_delay_PAD_RIGHT[i] = 0;
  
  if (previous_pad[i]&PAD_A && pad&PAD_A)
    ++input_delay_PAD_A[i];
  else
    input_delay_PAD_A[i] = 0;
  if (previous_pad[i]&PAD_B && pad&PAD_B)
    ++input_delay_PAD_B[i];
  else
    input_delay_PAD_B[i] = 0;

  //you have to look at the leftmost or rightmost puyo
  //p1 puyo 0 & 1, p2 puyo 2 & 3
  if (actor_x[i*2] < actor_x[(i*2)+1])
  {
    //left/right
    if ( pad&PAD_LEFT && (actor_x[i*2] > (16+(i*128))) && (actor_y[i*2] <= column_height[(actor_x[i*2] >> 4) - 2]) )
    {
      //add a bit of delay before going again to left
      if (input_delay_PAD_LEFT[i] == 0 || input_delay_PAD_LEFT[i] > INPUT_DIRECTION_DELAY)
      {
        actor_dx[i*2] = actor_x[i*2];
        actor_dx[(i*2)+1] = actor_x[(i*2)+1];
        actor_x[i*2] -= 16;
        actor_x[(i*2)+1] -= 16;
      }
    }
    else if ( pad&PAD_RIGHT && (actor_x[(i*2)+1] < (96+(i*128))) && (actor_y[(i*2)+1] <= column_height[(actor_x[(i*2)+1] >> 4)]) )
    {
      if (input_delay_PAD_RIGHT[i] == 0 || input_delay_PAD_RIGHT[i] > INPUT_DIRECTION_DELAY)
      {
        actor_dx[i*2] = actor_x[i*2];
        actor_dx[(i*2)+1] = actor_x[(i*2)+1];
        actor_x[i*2] += 16;
        actor_x[(i*2)+1] += 16;       
      }
    }
    else
    { //doing nothing
      /*actor_x[i*2] = 0;
          actor_x[(i*2)+1] = 0;*/
    }
    //buttons, the puyo rotating is always the one at the top
    //so with index at 0 (0 p1, 2 p2)
    if (pad&PAD_B && input_delay_PAD_B[i] == 0)
    { 
      //here as puyo[0] < puyo[1] we are at the left, if we press
      //B the puyo will go under the 2nd puyo
      //the delay has to be at 0, because we don't want it to turn automatically
      //you have to press each time        
      actor_dx[i*2] = actor_x[i*2];
      actor_y[i*2] += 16;
      actor_x[i*2] += 16;
    }
    if (pad&PAD_A && input_delay_PAD_A[i] == 0)
    { 
      //here as puyo[0] < puyo[1] we are at the left, if we press
      //A the puyo will go over the 2nd puyo
      actor_dx[i*2] = actor_x[i*2];
      actor_y[i*2] -= 16;
      actor_x[i*2] += 16;
    }   
  }
  else
  {

   // (actor_y[(i*2)+1] <= column_height[(actor_x[(i*2)+1] >> 4) - 1])

    if (actor_x[i*2] != actor_x[(i*2)+1])
    {
      //actor_x i is more to the right than actor_x i+1
      //going left or right
      if (pad&PAD_LEFT && (actor_x[(i*2)+1] > (16+i*128)) && (actor_y[(i*2)+1] <= column_height[(actor_x[(i*2)+1] >> 4) - 2]) )
      {
        if (input_delay_PAD_LEFT[i] == 0 || input_delay_PAD_LEFT[i] > INPUT_DIRECTION_DELAY)
        {
          actor_dx[i*2] = actor_x[i*2];
          actor_dx[(i*2)+1] = actor_x[(i*2)+1];
          actor_x[i*2] -= 16;
          actor_x[(i*2)+1] -= 16;
        }
      }
      else if (pad&PAD_RIGHT && (actor_x[i*2] < (96+i*128)) && (actor_y[i*2] <= column_height[(actor_x[i*2] >> 4)]) )
      {
        if (input_delay_PAD_RIGHT[i] == 0 || input_delay_PAD_RIGHT[i] > INPUT_DIRECTION_DELAY)
        {
          actor_dx[i*2] = actor_x[i*2];
          actor_dx[(i*2)+1] = actor_x[(i*2)+1];
          actor_x[i*2] += 16;
          actor_x[(i*2)+1] += 16;   
        }
      }

      //puyo[0] > puyo[1], it's on its right
      if (pad&PAD_B && input_delay_PAD_B[i] == 0)
      { 
        //here as puyo[0] > puyo[1] we are at the right, if we press
        //A the puyo will go over the 2nd puyo
        actor_dx[i*2] = actor_x[i*2];
        actor_y[i*2] -= 16;
        actor_x[i*2] -= 16;
      }
      if (pad&PAD_A && input_delay_PAD_A[i] == 0)
      { 
        //here as puyo[0] > puyo[1] we are at the right, if we press
        //A the puyo will go under the 2nd puyo
        actor_dx[i*2] = actor_x[i*2];
        actor_y[i*2] += 16;
        actor_x[i*2] -= 16; 
      }   
    }
    else
    {
      //left or right movement with both actor on the same x
      if (pad&PAD_LEFT && (actor_x[i*2] > (16+i*128)) && (actor_y[i*2] <= column_height[(actor_x[i*2] >> 4) - 2]) )
      {
        if (input_delay_PAD_LEFT[i] == 0 || input_delay_PAD_LEFT[i] > INPUT_DIRECTION_DELAY)
        {
          actor_dx[i*2] = actor_x[i*2];
          actor_dx[(i*2)+1] = actor_x[(i*2)+1];
          actor_x[i*2] -= 16;
          actor_x[(i*2)+1] -= 16;
        }
      }
      else if (pad&PAD_RIGHT && (actor_x[i*2] < (96+i*128)) && (actor_y[i*2] <= column_height[(actor_x[i*2] >> 4)]) )
      {
        if (input_delay_PAD_RIGHT[i] == 0 || input_delay_PAD_RIGHT[i] > INPUT_DIRECTION_DELAY)
        {
          actor_dx[i*2] = actor_x[i*2];
          actor_dx[(i*2)+1] = actor_x[(i*2)+1];
          actor_x[i*2] += 16;
          actor_x[(i*2)+1] += 16;
        }
      }
      
      //same x for both puyo
      //B we go on the left, A we go on the right
      if (pad&PAD_B && input_delay_PAD_B[i] == 0)
      { 
        //we need to know if puyo[0] is above or below puyo[1]
        // the lowest value is higher on the screen !
        if (actor_y[i*2] < actor_y[(i*2)+1])
        {
          //going from up to left
          ///are we on the side left side?
          if (actor_x[i*2] == (16+i*128))
          {
            //wall kick
            actor_dx[(i*2)+1] = actor_x[(i*2)+1];
            actor_x[(i*2)+1] += 16;
            actor_y[i*2] += 16;           
          }
          else
          {
            actor_dx[i*2] = actor_x[i*2];
            actor_x[i*2] -= 16;
            actor_y[i*2] += 16;
          }
        }
        else
        {  //going down to right
          if (actor_x[i*2] == (96+i*128))
          {
            //wall kick
            actor_dx[(i*2)+1] = actor_x[(i*2)+1];
            actor_x[(i*2)+1] -= 16;
            actor_y[i*2] -= 16;
          }
          else
          {
            actor_dx[i*2] = actor_x[i*2];
            actor_x[i*2] += 16;
            actor_y[i*2] -= 16; 
          }
        }
      }
      if (pad&PAD_A && input_delay_PAD_A[i] == 0)
      { 
        if (actor_y[i*2] < actor_y[(i*2)+1])
        {
          // going from up to right
          actor_dx[i*2] = actor_x[i*2];
          actor_x[i*2] += 16;
          actor_y[i*2] += 16;  
        }
        else
        {
          //going from down to left
          actor_dx[i*2] = actor_x[i*2];
          actor_x[i*2] -= 16;
          actor_y[i*2] -= 16; 
        }   
      } 
    }
  }
  //play rotation sound if button pressed
  if (pad&PAD_A || pad&PAD_B)
    play_rotation_sound();
  
  //test play bayoen_sample
  if (pad&PAD_START)
  {
    step_p2 = FALL_OJAMA;
    step_ojama_fall[1] = 0;
  }
  
  previous_pad[i] = pad;
}

void main(void)
{
  char i,j;	// actor index
  char str[32];
  register word addr;
  byte should_destroy = 0;

  setup_graphics();
  // draw message  
  vram_adr(NTADR_A(2,3));
  vram_write("HELLO BAYOEN", 12);
  build_field();
  generate_rng();
    
  // initialize actors
  //P1
  actor_x[0] = 3*16;
  actor_y[0] = 0*16;
  actor_dx[0] = 0;
  actor_dy[0] = 1;
  actor_x[1] = 3*16;
  actor_y[1] = 1*16;
  actor_dx[1] = 0;
  actor_dy[1] = 1;
  p1_puyo_list_index = 0;
  //P2
  actor_x[2] = 11*16;
  actor_y[2] = 0*16;
  actor_dx[2] = 0;
  actor_dy[2] = 1;
  actor_x[3] = 11*16;
  actor_y[3] = 1*16;
  actor_dx[3] = 0;
  actor_dy[3] = 1;
  p2_puyo_list_index = 0;
    
  previous_pad[0] = 0;
  previous_pad[1] = 0;
  input_delay_PAD_A[0] = 0;
  input_delay_PAD_A[1] = 0;
  input_delay_PAD_B[0] = 0;
  input_delay_PAD_B[1] = 0;
  input_delay_PAD_LEFT[0] = 0;
  input_delay_PAD_LEFT[1] = 0;
  input_delay_PAD_RIGHT[0] = 0;
  input_delay_PAD_RIGHT[1] = 0;
  timer_grace_period[0] = GRACE_PERIOD; 
  timer_grace_period[1] = GRACE_PERIOD;
  counter_falling_back_up[0] = MAX_FALLING_BACK_UP;
  counter_falling_back_up[1] = MAX_FALLING_BACK_UP;
  
  for (i = 0; i < 12 ; ++i)
    column_height[i] = 190;

  step_p1 = PLAY;
  step_p2 = PLAY;
  step_p1_counter = 0;
  step_p2_counter = 0;
  //update pairs to come
  update_next(0);
  update_next(1);
  
  //init score at 0
  memset(score,0,sizeof(score));

  //init sound & music
  apu_init();
  music_ptr = 0;
  // enable rendering
  ppu_on_all();
  //ppu_wait_frame();
  //scroll(0,240);
  // infinite loop
  while(1) {
    
    //set sound
    if (!music_ptr) start_music(music1);
    //get input
    oam_id = 0;

    if (oam_id!=0) 
      oam_hide_rest(oam_id);
    // ensure VRAM buffer is cleared
    ppu_wait_nmi();
    vrambuf_clear();
    
    if (step_p1 == 32)
      continue;
    
    if (step_p1 == PLAY)
    {
      handle_controler_and_sprites(0);
      for (i = 0 ; i < 2 ; ++i)
      {
        // puyoseq[0] == red, 1 blue, 2  green, 3 yellow, the good one is taken from
        // puyo_list       p1_puyo_list_index
        // (p1_puyo_list_index>>1) retourne le bon index puisqu'on a 4 paires par index
        // ensuite on décale sur le bon élément de l'index 
        // 2 bits pour chaque puyo=> on décale à droite (0<<0, 1<<2, 2<<4,3<<6)
        // et on fait & 3 pour ne garder que les 2 premiers bits    
        oam_id = oam_meta_spr(actor_x[i], actor_y[i], oam_id, puyoSeq[(puyo_list[(p1_puyo_list_index>>1)]>>((((p1_puyo_list_index%2)*2)+i)*2))&3]);

        if ( actor_dy[i] != 0) 
          actor_y[i] += (actor_dy[i] + ((previous_pad[0]&PAD_DOWN)? 2 : 0));

        //test relative to column_height
        if (actor_dy[i] != 0 && column_height[(actor_x[i] >> 4) - 1] < actor_y[i])
        {
          //actor_dx indicates if the x of the puyo has changed, and the column where it was
          if (actor_dx[i] != 0)
          {
            column_height[actor_dx[i]] += 16;
            actor_dx[i] = 0;
          }
          actor_dy[i] = 0;        
          actor_y[i] = column_height[(actor_x[i] >> 4) - 1];
          column_height[(actor_x[i]>>4) - 1] -= 16;
        }
      }
      
      if (timer_grace_period[0] < GRACE_PERIOD || (actor_dy[0] == 0 && actor_dy[1] == 0))
      {
        if (previous_pad[0]&PAD_DOWN)
          timer_grace_period[0] = 0;
        else
          --timer_grace_period[0];
        
        if (actor_x[i] == 0 && timer_grace_period[0] == 0)
          column_height[(actor_x[i]>>4) - 1] = actor_y[i];
      }
      
    }
    else
    {
      //we need to move oam_id to not have an offset, should be a better way though...
      oam_id = oam_meta_spr(actor_x[0], actor_y[0], oam_id, puyoSeq[(puyo_list[(p1_puyo_list_index>>1)]>>((((p1_puyo_list_index%2)*2)+0)*2))&3]);
      oam_id = oam_meta_spr(actor_x[1], actor_y[1], oam_id, puyoSeq[(puyo_list[(p1_puyo_list_index>>1)]>>((((p1_puyo_list_index%2)*2)+1)*2))&3]);
    }
   
    // ojama fall, only when opponent is in step "PLAY" when counter  is at 0
    // only 5 rows at a time, which will translate to 5*6 columns in our case
    // only if ojama[x], the damage score, is superior to 0
    // and if second row, the first visible, and third column is empty (top row : 0, so [2][1])
    if (step_p1 == FALL_OJAMA)
    {
      //fall_ojama(0);
      step_p1 = SHOW_NEXT;
    }

    if (step_p2 == FALL_OJAMA)
    {
      fall_ojama(1);
    }

    if (step_p1 == FALL)
    {
      //execute before destroy to avoid doing destroy and fall consecutively
      fall_board(0);
    }
    
    //update the next pair to come in the middle of the field
    if (step_p1 == SHOW_NEXT)
    {
      update_next(0);
      step_p1 = PLAY;
    }
    
    if (step_p2 == SHOW_NEXT)
    {
      update_next(1);
      step_p2 = PLAY;
    }
    
    if (step_p1 == POINT)
    {
      //executed before destroy to avoid doing destroy and fall consecutively
      if (step_p1_counter == 0)
        nb_hit[0] += 1;
      manage_point(0);
      ++step_p1_counter;
      if (step_p1_counter == 2)
      {
        step_p1 = FALL;
        step_p1_counter = 0;
      }
    }

    if (step_p1 == DESTROY)
    {
      //need to avoid to start check in the same loop
      //need to see if we need to subdivise the work in several pass
      destroy_board(0);
    }
    
    if (step_p1 == CHECK && step_p1_counter == 0)
    {
      //reinit variables for counting point
      nb_puyos_destroyed[0] = 0; //how many puyos are destroyed on that hit      
      //we keep only p2 maskcolor
      mask_color_destroyed =  mask_color_destroyed & 0xF0; // LSB p1, MSB p2, bit mask at 1 for each color present in the hit. bit 0 red, bit 1 blue, bit 2 green, 3 yellow 
      nb_group[0] = 0;//if the group is over 4 puyos add the part over in this variable.
      
      should_destroy = (check_board(0, ((actor_x[0]>>3) - 2) >> 1, ((actor_y[0]>>3)+1)>>1) > 0);
      //if both puyo had the same color it's unless to perform the second check
      if ( (boards[((actor_x[1]>>3) - 2) >> 1][((actor_y[1]>>3)+1)>>1] & 8) != 8)
        should_destroy = (check_board(0, ((actor_x[1]>>3) - 2) >> 1, ((actor_y[1]>>3)+1)>>1) > 0) || should_destroy;
      
      if (should_destroy)
      {
        step_p1_counter = 0;
        step_p1 = DESTROY;
        //let's move sprites to not have them on screen when things explode
        actor_x[0] = 255;
        actor_y[0] = 255;
        actor_x[1] = 255;
        actor_y[1] = 255;
        should_destroy = 0;
      }
      else
      {
        actor_x[0] = 3*16;
        actor_y[0] = 0;
        actor_x[1] = 3*16;
        actor_y[1] = 16;
        actor_dy[0] = 1;
        actor_dy[1] = 1;
        ++p1_puyo_list_index;
        /*
        step_p1 = SHOW_NEXT;*/
        step_p1 = FALL_OJAMA;
        step_p1_counter = 0;
        // step_p1 = DESTROY;
        // Need to reset the boards flag to 0 after destroy!
      }
    } else if (step_p1 == CHECK && step_p1_counter != 0)
    {
      step_p1_counter = 0;
    }
    
    //after fall (and so destroy) we need to recheck all the board
    //Everything is fallen at that point, so we can go from bottom
    //to top and stop searching as soon empty is found
    if (step_p1 == CHECK_ALL)
    {
      if (step_p1_counter < 78)
      { //Start from the left column and go right, do bottom
        //1 column per step to keep some CPU (hopefully)
        /*i = 12;
        //must not be empty (5) and must not have the flag (8) set !
        while ( ((boards[step_p1_counter][i] & 7) != EMPTY) &&
                ((boards[step_p1_counter][i] & 8) != 8) &&
               i <= 12 )
        {
          should_destroy = (check_board(0, step_p1_counter, i) > 0) || should_destroy ;
          --i;
        }*/
        i = step_p1_counter / 13;
        j = 13 - (step_p1_counter % 13);
        if (((boards[i][j] & 7) != EMPTY) && ((boards[i][j] & 8) != 8))
          should_destroy = (check_board(0, i, j) > 0) || should_destroy ;
        ++step_p1_counter;
        
        i = step_p1_counter / 13;
        j = 13 - (step_p1_counter % 13);
        if (((boards[i][j] & 7) != EMPTY) && ((boards[i][j] & 8) != 8))
          should_destroy = (check_board(0, i, j) > 0) || should_destroy ;
        ++step_p1_counter;
        
        i = step_p1_counter / 13;
        j = 13 - (step_p1_counter % 13);
        if (((boards[i][j] & 7) != EMPTY) && ((boards[i][j] & 8) != 8))
          should_destroy = (check_board(0, i, j) > 0) || should_destroy ;
        ++step_p1_counter;
      }
      else
      {
        //test is over, let's destroy if necessary
        if (should_destroy)
        {
          step_p1_counter = 0;
          step_p1 = DESTROY;
          should_destroy = 0;
        }
        else
        {
          actor_x[0] = 3*16;
          actor_y[0] = 0;
          actor_x[1] = 3*16;
          actor_y[1] = 16;
          actor_dy[0] = 1;
          actor_dy[1] = 1;
          ++p1_puyo_list_index;
          //step_p1 = SHOW_NEXT;
          step_p1 = FALL_OJAMA;
          step_p1_counter = 0;
          nb_hit[0] = 0;// hit combo counter
        }
      }    
    }
   
 
    if (step_p2 == PLAY)
    {
      handle_controler_and_sprites(1);
      for (i = 2 ; i < 4 ; ++i)
      {
        // puyoseq[0] == red, 1 blue, 2  green, 3 yellow, the good one is taken from
        // puyo_list       p1_puyo_list_index
        // (p1_puyo_list_index>>1) retourne le bon index puisqu'on a 4 paires par index
        // ensuite on décale sur le bon élément de l'index 
        // 2 bits pour chaque puyo=> on décale à droite (0<<0, 1<<2, 2<<4,3<<6)
        // et on fait & 3 pour ne garder que les 2 premiers bits
        oam_id = oam_meta_spr(actor_x[i], actor_y[i], oam_id, puyoSeq[(puyo_list[(p2_puyo_list_index>>1)]>>((((p2_puyo_list_index%2)*2)+(i-2))*2))&3]);
 
        actor_y[i] += (actor_dy[i] + ((previous_pad[1]&PAD_DOWN)? 2 : 0));

        //test relative to column_height
        /*if (actor_dy[i] != 0 && column_height[(actor_x[i]>>4) - 1] < actor_y[i])
        {
          actor_dy[i] = 0;
          actor_y[i] = column_height[(actor_x[i]>>4) - 1];
          column_height[(actor_x[i]>>4) - 1] -= 16;
        }*/
      }
    }

    //put_attr_entries(nt2attraddr(addr));

    if ( step_p1 == PLAY && actor_dy[0] == 0 && actor_dy[1] == 0 && actor_dx[0] == 0 && actor_dx[1] == 0 && timer_grace_period[0] == 0 )
    {
      //vrambuf_clear();
      memset(ntbuf1, 0, sizeof(ntbuf1));
      memset(ntbuf2, 0, sizeof(ntbuf2));
      memset(attrbuf, 0, sizeof(attrbuf));
      /*column_height[(actor_x[0]>>4) - 1] -= 16;
      column_height[(actor_x[1]>>4) - 1] -= 16;*/

      set_metatile(0,0xd8);
      //set_attr_entry((((actor_x[0]/8)+32) & 63)/2,0,return_sprite_color(0));
      //attrbuf should take the color for 4 tiles !
      attrbuf[0] = return_attribute_color(0, actor_x[0]>>3,(actor_y[0]>>3)+1, attribute_table);
      //HACK for unknown reason attribute_table is not correctly updated if function return_attribute_color is called twice
      //like here
      //attribute_table[(((actor_y[0]>>3)+1)<<1) + ((actor_x[0]>>3)>>2)] = attrbuf[0];
      set_metatile(1,0xd8);
      /*sprintf(str,"table:%d %d %d %d",attrbuf[0],actor_x[0]>>3,(actor_y[0]>>3)+1,(((actor_y[0]>>3)+1)<<1) + ((actor_x[0]>>3)>>2));
      addr = NTADR_A(1,26);
      vrambuf_put(addr,str,20);*/
      
      //set_attr_entry((((actor_x[1]/8)+32) & 63)/2,1,return_sprite_color(1));
      attrbuf[1] = return_attribute_color(1, actor_x[1]>>3, (actor_y[1]>>3)+1, attribute_table);/*return_sprite_color(1) + return_sprite_color(1)<<2 + return_sprite_color(1) << 4 + return_sprite_color(1) << 6*/;
      /*sprintf(str,"table:%d %d %d %d",attrbuf[1],actor_x[1]>>3,(actor_y[1]>>3)+1,(((actor_y[1]>>3)+1)<<1) + ((actor_x[1]>>3)>>2));
      addr = NTADR_A(1,27);
      vrambuf_put(addr,str,20);*/
      
      addr = NTADR_A((actor_x[0]>>3), (actor_y[0]>>3)+1);
      vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
      vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);
      vrambuf_put(nt2attraddr(addr), &attrbuf[0], 1);

      addr = NTADR_A((actor_x[1]>>3), (actor_y[1]>>3)+1);
      vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
      vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);
      vrambuf_put(nt2attraddr(addr), &attrbuf[1], 1);
      
      //updating the board, if things are done correctly attrbuf contains the color to be used
      //Still need to convert coordinates ! And not overwrite the value for the opponent board !
      update_boards(0);
     
      step_p1 = CHECK;
      //all commented below is now for another state
      /*
      if (check_board(0) > 0)
      {
        sprintf(str,"BOOM");
        addr = NTADR_A(20,15);
        vrambuf_put(addr,str,4);
      }
  
      actor_x[0] = 3*16;
      actor_y[0] = 0;
      actor_x[1] = 3*16;
      actor_y[1] = 16;
      actor_dy[0] = 1;
      actor_dy[1] = 1;
      p1_puyo_list_index++;*/
      
      //play sound of puyo hitting the ground
      play_puyo_fix();
      
      timer_grace_period[0] = GRACE_PERIOD; 
    }
    
    if (false && step_p2 == PLAY && actor_dy[2] == 0 && actor_dy[3] == 0)
    {/*
      set_metatile(2,0xd8);
      attrbuf[2] = return_attribute_color(2, actor_x[2]>>3,(actor_y[2]>>3)+1, attribute_table);

      set_metatile(3,0xd8);
      attrbuf[3] = return_attribute_color(3, actor_x[3]>>3, (actor_y[3]>>3)+1, attribute_table);

      addr = NTADR_A((actor_x[2]>>3), (actor_y[2]>>3)+1);
      vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
      vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);
      vrambuf_put(nt2attraddr(addr), &attrbuf[2], 1);

      addr = NTADR_A((actor_x[3]>>3), (actor_y[3]>>3)+1);
      vrambuf_put(addr|VRAMBUF_VERT, ntbuf1, 2);
      vrambuf_put(addr+1|VRAMBUF_VERT, ntbuf2, 2);
      vrambuf_put(nt2attraddr(addr), &attrbuf[3], 1);
      
      //update_boards(2); //see the function to know why "2" in parameter
 
      actor_x[2] = 11*16;
      actor_y[2] = 0;
      actor_x[3] = 11*16;
      actor_y[3] = 16;
      actor_dy[2] = 1;
      actor_dy[3] = 1;
      p2_puyo_list_index++;*/
      
    }
    
    sprintf(str,"S1:%d, %d", step_p1, step_p1_counter);
    addr = NTADR_A(20,15);
    vrambuf_put(addr,str,10);
    
    /*if (oam_id!=0) 
      oam_hide_rest(oam_id);
    // ensure VRAM buffer is cleared
    ppu_wait_nmi();
    vrambuf_clear();*/
    
    //scroll(0,0);
    //next music 
    play_music();
  }
}

//bach sonate pour violoncelle N°1
const byte music1[]= {
0x16,0x89,0x1d,0x89,0x26,0x89,0x24,0x89,0x26,0x89,0x1d,0x89,0x26,0x89,0x1d,0x89,0x16,0x89,0x1d,0x89,0x26,0x89,0x24,0x89,0x26,0x89,0x1d,0x89,0x26,0x89,0x1d,0x89,0x16,0x89,0x1f,0x89,0x27,0x89,0x26,0x89,0x27,0x89,0x1f,0x89,0x27,0x89,0x1f,0x89,0x16,0x89,0x1f,0x89,0x27,0x89,0x26,0x89,0x27,0x89,0x1f,0x89,0x27,0x89,0x1f,0x89,0x16,0x89,0x21,0x89,0x27,0x89,0x26,0x89,0x27,0x89,0x21,0x89,0x27,0x89,0x21,0x89,0x16,0x89,0x21,0x89,0x27,0x89,0x26,0x89,0x27,0x89,0x21,0x89,0x27,0x89,0x21,0x89,0x16,0x89,0x22,0x89,0x26,0x89,0x24,0x89,0x26,0x89,0x22,0x89,0x26,0x89,0x22,0x89,0x16,0x89,0x22,0x89,0x26,0x89,0x24,0x89,0x26,0x89,0x22,0x89,0x26,0x89,0x21,0x89,0x16,0x89,0x1f,0x89,0x26,0x89,0x24,0x89,0x26,0x89,0x22,0x89,0x21,0x89,0x22,0x89,0x1f,0x89,0x22,0x89,0x21,0x89,0x22,0x89,0x1a,0x89,0x1d,0x89,0x1c,0x89,0x1a,0x89,0x1c,0x89,0x22,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x22,0x89,0x1c,0x89,0x22,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x22,0x89,0x21,0x89,0x24,0x89,0x29,0x89,0x28,0x89,0x29,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x1d,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x13,0x89,0x1a,0x89,0x22,0x89,0x21,0x89,0x22,0x89,0x1a,0x89,0x22,0x89,0x1a,0x89,0x13,0x89,0x1a,0x89,0x22,0x89,0x21,0x89,0x22,0x89,0x1a,0x89,0x22,0x89,0x1a,0x89,0x13,0x89,0x1c,0x89,0x1d,0x89,0x1f,0x89,0x1d,0x89,0x1c,0x89,0x1a,0x89,0x18,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x29,0x89,0x28,0x89,0x26,0x89,0x24,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x29,0x89,0x24,0x89,0x29,0x89,0x21,0x89,0x24,0x89,0x1d,0x89,0x1f,0x89,0x21,0x89,0x24,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x23,0x89,0x1d,0x89,0x20,0x89,0x1f,0x89,0x20,0x89,0x1d,0x89,0x23,0x89,0x1d,0x89,0x26,0x89,0x1d,0x89,0x20,0x89,0x1f,0x89,0x20,0x89,0x1d,0x89,0x23,0x89,0x1d,0x89,0x1b,0x89,0x1f,0x89,0x24,0x89,0x26,0x89,0x27,0x89,0x24,0x89,0x1f,0x89,0x1d,0x89,0x1b,0x89,0x1f,0x89,0x24,0x89,0x26,0x89,0x27,0x89,0x24,0x89,0x21,0x89,0x1f,0x89,0x1e,0x89,0x21,0x89,0x1e,0x89,0x21,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x21,0x89,0x1e,0x89,0x21,0x89,0x1e,0x89,0x21,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x21,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x22,0x89,0x21,0x89,0x22,0x89,0x24,0x89,0x21,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x1b,0x89,0x1a,0x89,0x18,0x89,0x16,0x89,0x15,0x89,0x1b,0x89,0x1d,0x89,0x1b,0x89,0x1d,0x89,0x1b,0x89,0x1d,0x89,0x1b,0x89,0x15,0x89,0x1b,0x89,0x1d,0x89,0x1b,0x89,0x1d,0x89,0x1b,0x89,0x1d,0x89,0x1b,0x89,0x16,0x89,0x1a,0x89,0x20,0x89,0x1f,0x89,0x20,0x89,0x1a,0x89,0x20,0x89,0x1a,0x89,0x16,0x89,0x1a,0x89,0x20,0x89,0x1f,0x89,0x20,0x89,0x1a,0x89,0x20,0x89,0x1a,0x89,0x16,0x89,0x1b,0x89,0x1f,0x89,0x1d,0x89,0x1f,0x89,0x1b,0x89,0x1f,0x89,0x1b,0x89,0x16,0x89,0x1b,0x89,0x1f,0x89,0x1d,0x89,0x1f,0x89,0x1b,0x89,0x1f,0x89,0x1b,0x89,0x16,0x89,0x21,0x89,0x27,0x89,0x26,0x89,0x27,0x89,0x21,0x89,0x27,0x89,0x21,0x89,0x16,0x89,0x21,0x89,0x27,0x89,0x26,0x89,0x27,0x89,0x21,0x89,0x27,0x89,0x21,0x89,0x16,0x89,0x1d,0x89,0x26,0x89,0x24,0x89,0x26,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x1b,0x89,0x1a,0x89,0x18,0x89,0x16,0x89,0x15,0x89,0x13,0x89,0x11,0x89,0x10,0x89,0x18,0x89,0x1f,0x89,0x21,0x89,0x22,0x89,0x1f,0x89,0x21,0x89,0x22,0x89,0x10,0x89,0x18,0x89,0x1f,0x89,0x21,0x89,0x22,0x89,0x1f,0x89,0x21,0x89,0x22,0x89,0x0f,0x89,0x18,0x89,0x1d,0x89,0x1f,0x89,0x21,0x89,0x1d,0x89,0x1f,0x89,0x21,0x89,0x0f,0x89,0x18,0x89,0x1d,0x89,0x1f,0x89,0x21,0x89,0x1d,0x89,0x1f,0x89,0x21,0x89,0x0f,0x89,0x18,0x89,0x1d,0x89,0x21,0x89,0x24,0x89,0x28,0x89,0x29,0x9b,0x18,0x89,0x1a,0x89,0x1b,0x89,0x1d,0x89,0x1f,0x89,0x21,0x89,0x22,0x89,0x24,0x89,0x21,0x89,0x1d,0x89,0x1f,0x89,0x21,0x89,0x22,0x89,0x24,0x89,0x26,0x89,0x27,0x89,0x24,0x89,0x21,0x89,0x22,0x89,0x24,0x89,0x26,0x89,0x27,0x89,0x29,0x89,0x2a,0x89,0x29,0x89,0x28,0x89,0x29,0x89,0x29,0x89,0x27,0x89,0x26,0x89,0x27,0x89,0x27,0x89,0x24,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x18,0x89,0x1a,0x89,0x1b,0x89,0x11,0x89,0x18,0x89,0x1d,0x89,0x21,0x89,0x24,0x89,0x26,0x89,0x27,0x89,0x24,0x89,0x26,0x89,0x22,0x89,0x1d,0x89,0x1b,0x89,0x1a,0x89,0x16,0x89,0x18,0x89,0x1a,0x89,0x11,0x89,0x16,0x89,0x1a,0x89,0x1d,0x89,0x22,0x89,0x24,0x89,0x26,0x89,0x22,0x89,0x28,0x89,0x25,0x89,0x24,0x89,0x25,0x89,0x25,0x89,0x24,0x89,0x23,0x89,0x24,0x89,0x24,0x89,0x22,0x89,0x21,0x89,0x22,0x89,0x22,0x89,0x1f,0x89,0x1c,0x89,0x1a,0x89,0x18,0x89,0x1c,0x89,0x1f,0x89,0x22,0x89,0x24,0x89,0x28,0x89,0x29,0x89,0x28,0x89,0x29,0x89,0x24,0x89,0x21,0x89,0x1f,0x89,0x21,0x89,0x24,0x89,0x1d,0x89,0x21,0x89,0x18,0x89,0x1d,0x89,0x1c,0x89,0x1a,0x89,0x18,0x89,0x16,0x89,0x15,0x89,0x13,0x89,0x11,0x92,0x27,0x89,0x26,0x89,0x24,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x27,0x89,0x26,0x89,0x24,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x1b,0x89,0x26,0x89,0x24,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x1b,0x89,0x1a,0x89,0x24,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x1d,0x89,0x1b,0x89,0x1a,0x89,0x18,0x89,0x22,0x89,0x21,0x89,0x1f,0x89,0x21,0x89,0x24,0x89,0x1d,0x89,0x24,0x89,0x1f,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x1f,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x1d,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x1f,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x1d,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x1f,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x1d,0x89,0x24,0x89,0x1f,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x24,0x89,0x24,0x89,0x26,0x89,0x24,0x89,0x1d,0x89,0x24,0x89,0x24,0x89,0x24,0x89,0x26,0x89,0x24,0x89,0x27,0x89,0x24,0x89,0x1d,0x89,0x24,0x89,0x26,0x89,0x24,0x89,0x27,0x89,0x24,0x89,0x29,0x89,0x24,0x89,0x26,0x89,0x24,0x89,0x27,0x89,0x24,0x89,0x26,0x89,0x24,0x89,0x27,0x89,0x24,0x89,0x24,0x89,0x24,0x89,0x26,0x89,0x24,0x89,0x24,0x89,0x24,0x89,0x26,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x24,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x24,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x22,0x89,0x24,0x89,0x1f,0x89,0x24,0x89,0x21,0x89,0x24,0x89,0x1d,0x89,0x1f,0x89,0x20,0x89,0x1d,0x89,0x21,0x89,0x1d,0x89,0x22,0x89,0x1d,0x89,0x23,0x89,0x1d,0x89,0x24,0x89,0x1d,0x89,0x25,0x89,0x1d,0x89,0x26,0x89,0x1d,0x89,0x27,0x89,0x1d,0x89,0x28,0x89,0x1d,0x89,0x29,0x89,0x1d,0x89,0x2a,0x89,0x1d,0x89,0x2b,0x89,0x1d,0x89,0x2c,0x89,0x1d,0x89,0x2d,0x89,0x1d,0x89,0x2e,0x89,0x26,0x89,0x1d,0x89,0x26,0x89,0x2e,0x89,0x26,0x89,0x2e,0x89,0x26,0x89,0x2e,0x89,0x26,0x89,0x1d,0x89,0x26,0x89,0x2e,0x89,0x26,0x89,0x2e,0x89,0x26,0x89,0x2e,0x89,0x24,0x89,0x1d,0x89,0x24,0x89,0x2e,0x89,0x24,0x89,0x2e,0x89,0x24,0x89,0x2e,0x89,0x24,0x89,0x1d,0x89,0x24,0x89,0x2e,0x89,0x24,0x89,0x2e,0x89,0x24,0x89,0x2d,0x89,0x27,0x89,0x1d,0x89,0x27,0x89,0x2d,0x89,0x27,0x89,0x2d,0x89,0x27,0x89,0x2d,0x89,0x27,0x89,0x1d,0x89,0x27,0x89,0x2d,0x89,0x27,0x89,0x2d,0x89,0x27,0x89,0x16,0x26,0x2e,0xff
};
